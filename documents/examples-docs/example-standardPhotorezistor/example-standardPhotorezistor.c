// ****************************************************************************
//   Custom DPA Handler code example - IQRFBB-10 Development Board     *
// ****************************************************************************
// Copyright (c) logimic.com
//
// File:    example-standardPhotorezistor.c
// Version: Revision: 1.0
// Date:    Date: 2019/01/05
//
// Revision history:
//   2019/01/05  Release for DPA 3.02
//
// *********************************************************************

// Online DPA documentation http://www.iqrf.org/DpaTechGuide/

// This example implements 1 sensor according to the IQRF Sensors standard
// 1st sensor is light intensity indicator (value range is 0[max light]-127[max dark]).

// Default IQRF include (modify the path according to your setup)
#include "IQRF.h"

// Default DPA header (modify the path according to your setup)
#include "DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "DPAcustomHandler.h"
// IQRF standards header (modify the path according to your setup)
#include "IQRFstandard.h"
#include "IQRF_HWPID.h"

//############################################################################################

// Number of implemented sensors
#define	SENSORS_COUNT 1

// Variable to store sensor value at Get?_????() methods. This example implements sensors returning maximum 2 bytes of data.
uns16 sensorValue @ param3;

// Reads sensor value to the sensorValue variable and to responseFRCvalue(2B) variable
bit Get2_BinaryData_Light();

// Read preset PIC ADC for DDC-SE-01
uns8 ReadAdc();

// Stores sensor value byte(s) to the FSR1[+1...], in case of PCMD_STD_SENSORS_READ_TYPES_AND_VALUES sensor type is stored before value byte(s)
void StoreValue( uns8 sensorType );

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
bit CustomDpaHandler()
//############################################################################################
{
  // This forces CC5X to wisely use MOVLB instructions (doc says:  The 'default' bank is used by the compiler for loops and labels when the algorithm gives up finding the optimal choice)
#pragma updateBank default = UserBank_01

 
  // Handler presence mark
  clrwdt();

  // Sleeping parameters, valid when Time != 0
  static TPerOSSleep_Request PerOSSleep_Request;
  // Finite machine state
  static uns8 state; // = S_ResetConvertT = 0
  // Conversion timeout counter
  static uns8 timeout;

  // Detect DPA event to handle
  switch ( GetDpaEvent() )
  {
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the �empty� return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.

      // ms per TMR6 interrupt
#define	TICKS_LEN  10

      //  If TMR6 interrupt occurred
      if ( TMR6IF )
      {
        // Unmask interrupt
        TMR6IF = 0;
        // Decrement count
        if ( timeout != 0 )
          timeout--;
      }
      return Carry;

      // -------------------------------------------------
    case DpaEvent_Idle:
      // Do a quick background work when RF packet is not received

      // Should go to sleep?
      if ( PerOSSleep_Request.Time != 0 )
      {
        // Copy sleep parameters to the DPA request
        _DpaMessage.PerOSSleep_Request.Time = PerOSSleep_Request.Time;
        _DpaMessage.PerOSSleep_Request.Control = PerOSSleep_Request.Control;
        // Switch off sleeping time=flag
        PerOSSleep_Request.Time = 0;
        // Finalize OS Sleep DPA Request
        _DpaDataLength = sizeof( _DpaMessage.PerOSSleep_Request );
        _PNUM = PNUM_OS;
        _PCMD = CMD_OS_SLEEP;
        // Perform local DPA Request to go to sleep
        DpaApiLocalRequest();
      }



      // -------------------------------------------------
    case DpaEvent_Init:
      // Do a one time initialization work before main loop starts

      // Initialize sensors
      // C5 (AN4) as input 
      moduleInfo();
      // Connected TR pins?
      if ( !bufferINFO[5].7 )
      {
        TRISC.6 = 1;
        TRISB.4 = 1;
      }
      TRISA.5 = 1;

      // C1 (AN0) as input 
      TRISA.0 = 1;

      // Setup TMR6 to generate ticks on the background (ticks every 10ms)
#if F_OSC == 16000000
      PR6 = 250 - 1;
      T6CON = 0b0.1001.1.10;	// Prescaler 16, Postscaler 10, 16 * 10 * 250 = 40000 = 4MHz * 10ms
#else
#error Unsupported oscillator frequency
#endif


      // -------------------------------------------------
    case DpaEvent_AfterSleep:

      // -------------------------------------------------
    case DpaEvent_BeforeSleep:
      // Called before going to sleep

      // -------------------------------------------------
    case DpaEvent_DisableInterrupts:
      // Called when device needs all hardware interrupts to be disabled (before Reset, Restart and RFPGM)
      // Must not use TMR6 any more
      TMR6ON = FALSE;
      TMR6IE = FALSE;
      break;

      // -------------------------------------------------
    case DpaEvent_DpaRequest:
      // Called to interpret DPA request for peripherals
      // -------------------------------------------------
      // Peripheral enumeration
      if ( IsDpaEnumPeripheralsRequest() )
      {
        // We implement 1 standard user peripheral
        _DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1;
        FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_STD_SENSORS );
        _DpaMessage.EnumPeripheralsAnswer.HWPID = HWPID_IQRF_TECH__DEMO_DDC_SE01;
        _DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0x0001;

DpaHandleReturnTRUE:
        return TRUE;
      }
      // -------------------------------------------------
      // Get information about peripheral
      else if ( IsDpaPeripheralInfoRequest() )
      {
        if ( _PNUM == PNUM_STD_SENSORS )
        {
          _DpaMessage.PeripheralInfoAnswer.PerT = PERIPHERAL_TYPE_STD_SENSORS;
          _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_READ_WRITE;
          // Set standard version
          _DpaMessage.PeripheralInfoAnswer.Par1 = 13;
          goto DpaHandleReturnTRUE;
        }

        break;
      }
      // -------------------------------------------------
      else
      {
        // Handle peripheral command

        // Supported peripheral number?
        if ( _PNUM == PNUM_STD_SENSORS )
        {
          // Supported commands?
          switch ( _PCMD )
          {
            // Invalid command
            default:
              // Return error
              DpaApiReturnPeripheralError( ERROR_PCMD );

              // Sensor enumeration
            case PCMD_STD_ENUMERATE:
              if ( _DpaDataLength != 0 )
                goto _ERROR_DATA_LEN;

              // Then just enumerate their types
              _DpaMessage.Response.PData[0] = STD_SENSOR_TYPE_BINARYDATA7;

              W = SENSORS_COUNT;
              goto _W2_DpaDataLength;

              // Supported commands. They are handled the same way except one "if" at StoreValue() method
            case PCMD_STD_SENSORS_READ_VALUES:
            case PCMD_STD_SENSORS_READ_TYPES_AND_VALUES:
            {
              // No sensor bitmap specified? W = _DpaDataLength. Note: W is used to avoid MOVLB at next if
              W = _DpaDataLength;
              if ( W == 0 )	// Note: must not modify W
              {
                // Actually clears the bitmap
#if &_DpaMessage.Request.PData[0] != &bufferRF[0]
#error
#endif
                clearBufferRF();
                // Simulate 1st only sensor in the bitmap (states of the other unimplemented sensors do not care)
                _DpaMessage.Request.PData[0].0 = 1;
                // Bitmap is 32 bits long = 4
                _DpaDataLength = W = 4;
              }

              // Invalid bitmap (data) length (W = _DpaDataLength)?
              if ( W != 4 )
              {
_ERROR_DATA_LEN:
                // Return error
                DpaApiReturnPeripheralError( ERROR_DATA_LEN );
              }

              // Now read the sensors

              // Prepare pointer (minus 1, see below) to store sensor (types and) values to
              // Note: 4 sensors at this example cannot return more than DPA_MAX_DATA_LENGTH bytes of data, so it does not have to be checked...
              // ... If it would be the case, then ERROR_FAIL must be returned
              FSR1 = &_DpaMessage.Response.PData[-1];

              // Store bitmap of sensors to get values from
              uns8	sensorsBitmap = FSR1[1];

              // 1st sensor (index 0) selected?
              if ( sensorsBitmap.0 )
              {
                Get2_BinaryData_Light();
                StoreValue( STD_SENSOR_TYPE_BINARYDATA7 );
              }

              // Compute returned data bytes count
              W = FSR1L - ( (uns16)&_DpaMessage.Response.PData[0] & 0xFF ) + 1;
              // Optimization: return W long block of bytes at response
_W2_DpaDataLength:
              _DpaDataLength = W;
              goto DpaHandleReturnTRUE;
            }
          }
        }

        break;
      }

      // -------------------------------------------------
    case DpaEvent_FrcValue:
      // Called to get FRC value

      // FSR1 for optimization purposes (avoid MOVLB) will be used to point to DataOutBeforeResponseFRC[0...]
      FSR1 = &DataOutBeforeResponseFRC[0];
      // Check for correct FRC user data
      if ( *FSR1++ /*DataOutBeforeResponseFRC[0]*/ == PNUM_STD_SENSORS )
      {
        // Actually used sensor index
        uns8 sensorIndex = FSR1[1] /*DataOutBeforeResponseFRC[2]*/ & 0x1f;
        // Test sensor type
        switch ( *FSR1++ /*DataOutBeforeResponseFRC[1]*/ )
        {
          default:
            goto DpaHandleReturnFALSE;

            // No type specified, use specified index value
          case 0x00:
            goto _KeepSensorIndex;

            // For other types make the index value based on the requested index value and sensor type
          case STD_SENSOR_TYPE_TEMPERATURE:
            if ( sensorIndex > 1 )
              goto DpaHandleReturnFALSE;
            W = 0 + sensorIndex;
            break;

          case STD_SENSOR_TYPE_BINARYDATA7:
            if ( sensorIndex > 1 )
              goto DpaHandleReturnFALSE;
            W = 2 + sensorIndex;
            break;
        }

        // New sensor index based on type and requested index
        sensorIndex = W;
_KeepSensorIndex:

        // Test for supported FRC commands
        switch ( _PCMD )
        {
          default:
            goto DpaHandleReturnFALSE;

          case FRC_STD_SENSORS_BIT:
          case FRC_STD_SENSORS_1B:
          case FRC_STD_SENSORS_2B:
            switch ( sensorIndex )
            {
              default:
                goto DpaHandleReturnFALSE;

              case 0:
                Carry = Get2_BinaryData_Light();
                break;
            }

            // This type of FRC is not valid for the specified sensor
            if ( !Carry )
              goto DpaHandleReturnFALSE;

            break;
        }

        // Some sensor was measured by FRC, check if there is a sleep request
        FSR1++;
        if ( INDF1.0 ) // Note: same as DataOutBeforeResponseFRC[3].0
        {
          // Remember sleep parameters to go to sleep at the Idle event later
          PerOSSleep_Request.Time.low8 = FSR1[4 - 3]; // Note: same as DataOutBeforeResponseFRC[4];
          PerOSSleep_Request.Time.high8 = FSR1[5 - 3]; // Note: same as DataOutBeforeResponseFRC[5];
          PerOSSleep_Request.Control = FSR1[6 - 3]; // Note: same as DataOutBeforeResponseFRC[6];
        }
      }

      break;

      // -------------------------------------------------
    case DpaEvent_FrcResponseTime:
      // Called to get FRC response time

      // In this example the FRC commands are fast 
      switch ( DataOutBeforeResponseFRC[0] )
      {
        case FRC_STD_SENSORS_BIT:
        case FRC_STD_SENSORS_1B:
        case FRC_STD_SENSORS_2B:
          responseFRCvalue = _FRC_RESPONSE_TIME_40_MS;
          break;
      }
      break;
  }
DpaHandleReturnFALSE:
  return FALSE;
}

//############################################################################################
// Increases FSR1 and then stores the byte
void setPlusPlusINDF1( uns8 data @ W )
//############################################################################################
{
  FSR1++; // Note: must not modify W
  setINDF1( data );
}

//############################################################################################
// Stores measured sensor value byte(s) and optionally sensor type to the FSR[+1...]
void StoreValue( uns8 sensorType )
//############################################################################################
{
  // Is the sensor type to be stored too?
  if ( _PCMD == PCMD_STD_SENSORS_READ_TYPES_AND_VALUES )
    setPlusPlusINDF1( sensorType );

  // Store lower value byte
  setPlusPlusINDF1( sensorValue.low8 );

  // No more value bytes to store?
  if ( sensorType.7 != 0 )
    return;

  // Store higher value byte
  setPlusPlusINDF1( sensorValue.high8 );

  // Note: this example implements sensors returning only 1 or 2 bytes of data. If another data widths are returned, then it must be implemented explicitly.
}

//############################################################################################
bit setFRCerror()
//############################################################################################
{
  responseFRCvalue2B = 2;
  return TRUE;
}

//############################################################################################
bit AdjustFrcBinaryData()
//############################################################################################
{
  // Test for supported FRC commands
  switch ( _PCMD )
  {
    default:
      return FALSE;

    case FRC_STD_SENSORS_BIT:
      // If there is a sensor error, 2-bit FRC cannot indicate it, it returns [01]

      // Number of shifts to get the bit out of the return value
      uns8 bitLoop = ( INDF1 >> 5 ) + 1;
      // Value to get the bit from
      W = sensorValue.low8;
      do
      {
        // Get the bit to Carry
        W = rr( W );
        // Next bit
      } while ( --bitLoop != 0 ); // Note: must not modify W and Carry
      // Current (prepared by DPA) FRC value is [01], change it to [11] (means bit is set)
      responseFRCvalue.1 = 1; // Note: must not modify Carry
      // Is bit set?
      if ( !Carry )
        // Bit is NOT set, return [10]
        responseFRCvalue.0 = 0;
      break;

    case FRC_STD_SENSORS_1B:
      responseFRCvalue = sensorValue.low8 + 4;
      break;
  }
  return TRUE;
}

//############################################################################################
// Sensor index 2: returns light intensity indicator value using DDC-SE-01
bit Get2_BinaryData_Light()
//############################################################################################
{
  // Make sure FSR1 is not modified

  // ADC initialization (for more info see PIC datasheet) pin C1 (AN0) as analog input 
  ANSELA.0 = 1;
  // ADC setting (AN0 channel)
  ADCON0 = 0b0.00000.01;
  // Read ADC
  sensorValue.low8 = ReadAdc() / 2;
  // Return sensor FRC value
  return AdjustFrcBinaryData();
}

//############################################################################################
uns8 ReadAdc()
//############################################################################################
{
  // ADC result - left justified, Fosc/8
  ADCON1 = 0b0001.0000;
  // Do a smallest delay for ADC ACQUISITION TIME
  waitMS( 1 );
  // start ADC
  GO = 1;
  // wait for ADC finish
  while ( GO );
  return ADRESH;
}

//############################################################################################
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "DPAcustomHandler.h"
//############################################################################################
