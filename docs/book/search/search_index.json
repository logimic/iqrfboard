{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started with IQRFBB-10 IQRFBB-10 development board helps you to design IOT devices for IQRF wireless network. Simply connect sensor or actuator you want to, join the board to IQRF network and device is ready. If you are satisfied with such working device scale IQRFBB-10 layout to final product and your IOT product is done. In this tutorial we will show you: How to prepare IQRF network. How to connect IQRFBB-10 to the IQRF network as a node. How to connect different sensors to the board. How to communicate with the board from your software via IQRF gateway. Links IQRFBB-10 Presentation & Buy IQRFBB-10 GitHub pages IQRFBB-10 Data Sheet IQRFBB-10 Data Sheet (pdf) IQRFBB-10 Board Schema (pdf) IQRFBB-10 Hardware Drawing (pdf) TR-76D Transciever TR-76D Datasheet Prepare IQRF network Firs check IQRF network around you. If you do not have any, let's start with this tutorial SetupIqrfNetwork . Assemble Board JP1: OFF JP6: OFF Insert IQRF TR into board Connect Programmer Unplug USB cable from CK-USB-04A Unplug IQRFBB-10 from microUSB and JP6=OFF. Unplug TR module JP1=OFF. Make wiring Plug JP4=ON, JP1=OFF. Plug micro-USB to IQRFBB-10 to power-on. Indication LD1=ON (charging battery), LD4=ON Plug micro-USB to CK-USB-04A Now the board is ready for software loading Load Software If we are talking about software loading, we always mean loading software to IQRF transceiver TR-76D mounted on IQRFBB-10. Via software load you configure transceiver within IQRF network. Now we will configure board (transceiver) as a node of IQRF network. Make sure you made a proper wiring and both USB power sources (programmer + board) are on. Now you can upload node configuration as described in preparation of your IQRF network chapter . Do not put any IQRF module into CK-USB-04A programmer SIM! Uploading data into transciever is sihnalized by LD3 diod on IQRFBB-10 board. Unplug micro USB of CK-USB-04A programmer Unplug micro USB of IQRFBB-10 board. Unplug CK-USB-04A from IQRFBB-10. Bond to Network Bonding IQRF nodes is generally described here... , bonding IQRFBB-10 board goes this way: Turn on battery power JP6 = ON . Diod indicating power on is LD4 = ON . Turn TR module power JP1 = ON . Open IDE, then menu start Tools/IQMESH Network Manager and fill out the dialogue as shown (TX power, Auto address, ...). Then pres Clear All Bonds for remove any previous bonded modules. Red diods of modules are blinking, at IQRFBB-10 it is diod LD3 . Then pres Bond Node and during bonding period press and hold SW1 button at one node until green diod turns on. Repeat for each node. At IQRFBB-10 the SW1 is an external contact EQ12, GND , red diod is LD3 and green diods is LD2 . Now you should see yellow spots indicating successful bonding. Now click Discovery and spots are in blue. Switch in IDE to Map View and you should see node structure something like in the picture. Try to turn on LD3 (RED diod) on IQRFBB-10 board. Click rigt mouse button on spot indicating board (it depends on the bonding order) and select LED Red On . Then the LD3 = ON on the board. Check Operability Now you have fully configured IQRFBB-10 board. You can check operability this way: Battery power turn on/off is always done via JP6 . When you power board on, then it is always automatically connected to the IQRF network (if you properly did all steps above). For checking of connectivity open IDE and in IQMESH Network Manager , view Control click Discovery button. Working nodes are displayed in blue spots, previously bonded but inactive are shown as yellow spots. Switch to Map View , find IQRF-BB10 node (one of blue spheres) and try to turn on LD3 (RED diod) on IQRFBB-10 board. Right click mouse button on spot indicating board and select LED Red On . Then the LD3 = ON on the board. Examples Now we can make from IQRFBB-10 any wireless sensor or actuator by wiring proper sensor or actuators. Let's continue to our examples","title":"Getting Started with IQRFBB-10"},{"location":"#getting-started-with-iqrfbb-10","text":"IQRFBB-10 development board helps you to design IOT devices for IQRF wireless network. Simply connect sensor or actuator you want to, join the board to IQRF network and device is ready. If you are satisfied with such working device scale IQRFBB-10 layout to final product and your IOT product is done. In this tutorial we will show you: How to prepare IQRF network. How to connect IQRFBB-10 to the IQRF network as a node. How to connect different sensors to the board. How to communicate with the board from your software via IQRF gateway.","title":"Getting Started with IQRFBB-10"},{"location":"#links","text":"IQRFBB-10 Presentation & Buy IQRFBB-10 GitHub pages IQRFBB-10 Data Sheet IQRFBB-10 Data Sheet (pdf) IQRFBB-10 Board Schema (pdf) IQRFBB-10 Hardware Drawing (pdf) TR-76D Transciever TR-76D Datasheet","title":"Links"},{"location":"#prepare-iqrf-network","text":"Firs check IQRF network around you. If you do not have any, let's start with this tutorial SetupIqrfNetwork .","title":"Prepare IQRF network"},{"location":"#assemble-board","text":"JP1: OFF JP6: OFF Insert IQRF TR into board","title":"Assemble Board"},{"location":"#connect-programmer","text":"Unplug USB cable from CK-USB-04A Unplug IQRFBB-10 from microUSB and JP6=OFF. Unplug TR module JP1=OFF. Make wiring Plug JP4=ON, JP1=OFF. Plug micro-USB to IQRFBB-10 to power-on. Indication LD1=ON (charging battery), LD4=ON Plug micro-USB to CK-USB-04A Now the board is ready for software loading","title":"Connect Programmer"},{"location":"#load-software","text":"If we are talking about software loading, we always mean loading software to IQRF transceiver TR-76D mounted on IQRFBB-10. Via software load you configure transceiver within IQRF network. Now we will configure board (transceiver) as a node of IQRF network. Make sure you made a proper wiring and both USB power sources (programmer + board) are on. Now you can upload node configuration as described in preparation of your IQRF network chapter . Do not put any IQRF module into CK-USB-04A programmer SIM! Uploading data into transciever is sihnalized by LD3 diod on IQRFBB-10 board. Unplug micro USB of CK-USB-04A programmer Unplug micro USB of IQRFBB-10 board. Unplug CK-USB-04A from IQRFBB-10.","title":"Load Software"},{"location":"#bond-to-network","text":"Bonding IQRF nodes is generally described here... , bonding IQRFBB-10 board goes this way: Turn on battery power JP6 = ON . Diod indicating power on is LD4 = ON . Turn TR module power JP1 = ON . Open IDE, then menu start Tools/IQMESH Network Manager and fill out the dialogue as shown (TX power, Auto address, ...). Then pres Clear All Bonds for remove any previous bonded modules. Red diods of modules are blinking, at IQRFBB-10 it is diod LD3 . Then pres Bond Node and during bonding period press and hold SW1 button at one node until green diod turns on. Repeat for each node. At IQRFBB-10 the SW1 is an external contact EQ12, GND , red diod is LD3 and green diods is LD2 . Now you should see yellow spots indicating successful bonding. Now click Discovery and spots are in blue. Switch in IDE to Map View and you should see node structure something like in the picture. Try to turn on LD3 (RED diod) on IQRFBB-10 board. Click rigt mouse button on spot indicating board (it depends on the bonding order) and select LED Red On . Then the LD3 = ON on the board.","title":"Bond to Network"},{"location":"#check-operability","text":"Now you have fully configured IQRFBB-10 board. You can check operability this way: Battery power turn on/off is always done via JP6 . When you power board on, then it is always automatically connected to the IQRF network (if you properly did all steps above). For checking of connectivity open IDE and in IQMESH Network Manager , view Control click Discovery button. Working nodes are displayed in blue spots, previously bonded but inactive are shown as yellow spots. Switch to Map View , find IQRF-BB10 node (one of blue spheres) and try to turn on LD3 (RED diod) on IQRFBB-10 board. Right click mouse button on spot indicating board and select LED Red On . Then the LD3 = ON on the board.","title":"Check Operability"},{"location":"#examples","text":"Now we can make from IQRFBB-10 any wireless sensor or actuator by wiring proper sensor or actuators. Let's continue to our examples","title":"Examples"},{"location":"About/","text":"About IQRFBB-10 project is powered by www.logimic.com Orders & Project Presentation logimic.com/iqrfboard Licensing All content in the repository is licensed via the MIT license","title":"About"},{"location":"About/#about","text":"IQRFBB-10 project is powered by www.logimic.com Orders & Project Presentation logimic.com/iqrfboard","title":"About"},{"location":"About/#licensing","text":"All content in the repository is licensed via the MIT license","title":"Licensing"},{"location":"Examples/","text":"Basic examples 1. LED2, LED3 on board First hello world example which turns on/off RED and GREEN diods on the IQRFBB-10 board. Enter example... 2. Digital Output This example shows how to set HI/LO digital output. The DO has connected external LED. Enter example.. 3. Digital Input This example explains how to detect digital input on board PIN. Enter example... , Standard Things Standard things have pre-defined JSON API and all IQRF gateways know them. If you implement your device in TR module as Standard Light , Standard Binary Output , Standard Sensor and more you have ensured compatibility of your device with IOT world. 1. Standard Light This example shows how to create \"Standard light\" from your board which means that entire world will know that your device is just a light and will be able to manage it (turn on/off, dim, get status and more). Your hardware design on the top of board is not limited. Enter example... 2. Standard Binary Output This example shows how to create one or more standard binary outputs on the board. Enter example.. Others.. 1. Hall Magnetic Sensor /example-hall , this example shows how to connect Hall Magentic Sensor with the board and detect event. 2. Motion detection (ePir) /example-ePir , this example shows how to connect motion sensor ePir to the board and detect event. 3. Bi-stable relay on board /example-bistable-relay , this example shows how to switch bi-stable relay on board. 4. HTU21D - Temp & Humidity Comming soon HTU21D... /example-HTU21D , this example shows how to connect HTU21D Temperature and Humidity sensor to board. 5. GY-BME280 - Temp & Baro Comming soon GY-BME280... 6. Ambient Light Sensor Comming soon GY49...","title":"Examples"},{"location":"Examples/#basic-examples","text":"","title":"Basic examples"},{"location":"Examples/#1-led2-led3-on-board","text":"First hello world example which turns on/off RED and GREEN diods on the IQRFBB-10 board. Enter example...","title":"1. LED2, LED3 on board"},{"location":"Examples/#2-digital-output","text":"This example shows how to set HI/LO digital output. The DO has connected external LED. Enter example..","title":"2. Digital Output"},{"location":"Examples/#3-digital-input","text":"This example explains how to detect digital input on board PIN. Enter example... ,","title":"3. Digital Input"},{"location":"Examples/#standard-things","text":"Standard things have pre-defined JSON API and all IQRF gateways know them. If you implement your device in TR module as Standard Light , Standard Binary Output , Standard Sensor and more you have ensured compatibility of your device with IOT world.","title":"Standard Things"},{"location":"Examples/#1-standard-light","text":"This example shows how to create \"Standard light\" from your board which means that entire world will know that your device is just a light and will be able to manage it (turn on/off, dim, get status and more). Your hardware design on the top of board is not limited. Enter example...","title":"1. Standard Light"},{"location":"Examples/#2-standard-binary-output","text":"This example shows how to create one or more standard binary outputs on the board. Enter example..","title":"2. Standard Binary Output"},{"location":"Examples/#others","text":"","title":"Others.."},{"location":"Examples/#1-hall-magnetic-sensor","text":"/example-hall , this example shows how to connect Hall Magentic Sensor with the board and detect event.","title":"1. Hall Magnetic Sensor"},{"location":"Examples/#2-motion-detection-epir","text":"/example-ePir , this example shows how to connect motion sensor ePir to the board and detect event.","title":"2. Motion detection (ePir)"},{"location":"Examples/#3-bi-stable-relay-on-board","text":"/example-bistable-relay , this example shows how to switch bi-stable relay on board.","title":"3. Bi-stable relay on board"},{"location":"Examples/#4-htu21d-temp-humidity","text":"Comming soon HTU21D... /example-HTU21D , this example shows how to connect HTU21D Temperature and Humidity sensor to board.","title":"4. HTU21D - Temp &amp; Humidity"},{"location":"Examples/#5-gy-bme280-temp-baro","text":"Comming soon GY-BME280...","title":"5. GY-BME280 - Temp &amp; Baro"},{"location":"Examples/#6-ambient-light-sensor","text":"Comming soon GY49...","title":"6. Ambient Light Sensor"},{"location":"IQRFBB10-Datasheet/","text":"IQRFBB10 Data Sheet Revision: 1.0, Nov-2018 1. Description IQRFBB10 is development board for prototyping of end devices (nodes) of IQRF network. Board includes socket for IQRF transciever module plugin and enables connection of any sensors, acttuators via DI, DIO, or I2C interfaces. Software operation of sensors and data transfer is performed in MCU of IQRF radio transciever module. 2. Specification Power supply - Accumulator LIP552240, 400 mAh, nominal voltage 3.7 V - Via micro USB connector (with charging) 4.4 V to 6.0 V DC - External power supply 5-12 V - External accumulator pres X6, nominal voltage 3.7 V Supply current - ??? Temperature operating - Accumulator not charged -20\u00b0C to +60\u00b0C - Accumulator charged 0 \u00b0C to +45 \u00b0C Storage Temperature -20\u00b0C to +20\u00b0C (1 year), +10\u00b0C to +25\u00b0C recommended Supported TR modules TR-76DA and similar Dimensions 60 mm x 85 mm x 23 mm Weight 30g 3. Simple scheme Fig1. Simple schema of IQRF BB-10 board 4. Features Name Type Description U4 IQRF TR module socket Bat1 LIR2032 Chargeable battery USB uUSD_to_DIP PCB adapter Bist-rel ME-6C-L1-03-1a1b Bi-stable relay 3V RE-STD IM-HICPD Standard releay 5. PINs specification Pin Name Description VCC Power supply voltage GND Ground SCL I2C clock SDA I2C data EQ13 TA General input only pin EQ12 SW1 GND SW1 Ground NC1 Bi-stable relay TH COM1 Bi-stable relay TH NO1 Bi-stable relay TH NO2 COM2 Bi-stable relay SMD NC2 Bi-stable relay SMD RE+ Output for power supply of Bi-stable relay (+/- 3V) RE- Output for power supply of Bi-stable relay (+/- 3V) RE Output for power supply of Bi-stable relay RE+++ Output for power supply of Bi-stable relay NC4 Standard relay COM4 Standard relay NO4 Standard relay MB1 C1 MB2 C2 MB3 VO MB4 MB5 VCC MB6 MB7 MB8 X13 Contact of Standard relay (paket_2) PGM 1 VCC PGM 2 GND PGM 3 SCK PGM 4 SDI PGM 5 SDO PGM 6 SS IQRF module PIN mapping PIN IQRF PIN XQ2 GND XQ3 VCC XQ4 Q4 XQ5 Q5 XQ6 Q6 XQ7 Q7 XQ8 Q8 XQ9 Q9 XQ10 Q10 XQ11 Q11 XQ12 Q12 XQ13 Q13 XQ14 Q14 XQ15 Q15 6. Jumpers Jumper Description Description JP1 VCC_SW Enable connection of local source 3V. Note: connect local source after un-plug of programmer! JP2 Power cupply choise 1-2: LiPol/USB adapter 5V (board works withouth battery) 2-3: external power supply 5-16V z X1 JP3 JP4 VCC_SW Connects indication of powwer supplyLD4-Y (3V) JP5 Host_mode at Android devices if possible JP6 VCC_SW Connects battery to power supply X6 Connects external Lipol battery 7. Diods Diod Name Description LD1 LED-P LD2 LED-G LD3 LED-R LD4 LED-Y Indication of power supply (3V) LD5 LED-B LD6 LED-W LD7 LED-O 8. Operation conditions TODO 9. Programmer connection Fig2. programmer connection with IQRF BB-10 board Connect with CK-USB-04A programmer. No TR module in programmer. 10. Detail scheme Fig3. Detail scheme of IQRF BB-10 board 11. Contacts www.logimic.com","title":"Data Sheet"},{"location":"IQRFBB10-Datasheet/#iqrfbb10-data-sheet","text":"Revision: 1.0, Nov-2018","title":"IQRFBB10 Data Sheet"},{"location":"IQRFBB10-Datasheet/#1-description","text":"IQRFBB10 is development board for prototyping of end devices (nodes) of IQRF network. Board includes socket for IQRF transciever module plugin and enables connection of any sensors, acttuators via DI, DIO, or I2C interfaces. Software operation of sensors and data transfer is performed in MCU of IQRF radio transciever module.","title":"1. Description"},{"location":"IQRFBB10-Datasheet/#2-specification","text":"Power supply - Accumulator LIP552240, 400 mAh, nominal voltage 3.7 V - Via micro USB connector (with charging) 4.4 V to 6.0 V DC - External power supply 5-12 V - External accumulator pres X6, nominal voltage 3.7 V Supply current - ??? Temperature operating - Accumulator not charged -20\u00b0C to +60\u00b0C - Accumulator charged 0 \u00b0C to +45 \u00b0C Storage Temperature -20\u00b0C to +20\u00b0C (1 year), +10\u00b0C to +25\u00b0C recommended Supported TR modules TR-76DA and similar Dimensions 60 mm x 85 mm x 23 mm Weight 30g","title":"2. Specification"},{"location":"IQRFBB10-Datasheet/#3-simple-scheme","text":"Fig1. Simple schema of IQRF BB-10 board","title":"3. Simple scheme"},{"location":"IQRFBB10-Datasheet/#4-features","text":"Name Type Description U4 IQRF TR module socket Bat1 LIR2032 Chargeable battery USB uUSD_to_DIP PCB adapter Bist-rel ME-6C-L1-03-1a1b Bi-stable relay 3V RE-STD IM-HICPD Standard releay","title":"4. Features"},{"location":"IQRFBB10-Datasheet/#5-pins-specification","text":"Pin Name Description VCC Power supply voltage GND Ground SCL I2C clock SDA I2C data EQ13 TA General input only pin EQ12 SW1 GND SW1 Ground NC1 Bi-stable relay TH COM1 Bi-stable relay TH NO1 Bi-stable relay TH NO2 COM2 Bi-stable relay SMD NC2 Bi-stable relay SMD RE+ Output for power supply of Bi-stable relay (+/- 3V) RE- Output for power supply of Bi-stable relay (+/- 3V) RE Output for power supply of Bi-stable relay RE+++ Output for power supply of Bi-stable relay NC4 Standard relay COM4 Standard relay NO4 Standard relay MB1 C1 MB2 C2 MB3 VO MB4 MB5 VCC MB6 MB7 MB8 X13 Contact of Standard relay (paket_2) PGM 1 VCC PGM 2 GND PGM 3 SCK PGM 4 SDI PGM 5 SDO PGM 6 SS","title":"5. PINs specification"},{"location":"IQRFBB10-Datasheet/#iqrf-module-pin-mapping","text":"PIN IQRF PIN XQ2 GND XQ3 VCC XQ4 Q4 XQ5 Q5 XQ6 Q6 XQ7 Q7 XQ8 Q8 XQ9 Q9 XQ10 Q10 XQ11 Q11 XQ12 Q12 XQ13 Q13 XQ14 Q14 XQ15 Q15","title":"IQRF module PIN mapping"},{"location":"IQRFBB10-Datasheet/#6-jumpers","text":"Jumper Description Description JP1 VCC_SW Enable connection of local source 3V. Note: connect local source after un-plug of programmer! JP2 Power cupply choise 1-2: LiPol/USB adapter 5V (board works withouth battery) 2-3: external power supply 5-16V z X1 JP3 JP4 VCC_SW Connects indication of powwer supplyLD4-Y (3V) JP5 Host_mode at Android devices if possible JP6 VCC_SW Connects battery to power supply X6 Connects external Lipol battery","title":"6. Jumpers"},{"location":"IQRFBB10-Datasheet/#7-diods","text":"Diod Name Description LD1 LED-P LD2 LED-G LD3 LED-R LD4 LED-Y Indication of power supply (3V) LD5 LED-B LD6 LED-W LD7 LED-O","title":"7. Diods"},{"location":"IQRFBB10-Datasheet/#8-operation-conditions","text":"TODO","title":"8. Operation conditions"},{"location":"IQRFBB10-Datasheet/#9-programmer-connection","text":"Fig2. programmer connection with IQRF BB-10 board Connect with CK-USB-04A programmer. No TR module in programmer.","title":"9. Programmer connection"},{"location":"IQRFBB10-Datasheet/#10-detail-scheme","text":"Fig3. Detail scheme of IQRF BB-10 board","title":"10. Detail scheme"},{"location":"IQRFBB10-Datasheet/#11-contacts","text":"www.logimic.com","title":"11. Contacts"},{"location":"IqrfGatewayDaemon/","text":"IQRF Gateway Daemon IQRF network is hidden behind coordinator connected to your computer via USB, SPI, UART or other types of interface. Communication between your program and coordinator is ensured via IQRF Gateway Daemon software module. This is Open Source gateway piece of software for communicating (sending and receiving JSON API messages) with IQRF network. This is included in many IQRF gateways and you can also download it and build for your platform. Links IQRF Gateway Daemon Sources IQRF Gateway Daemon Release for Win IQRF Gateway Daemon Documentation Run Daemon You can run Daemon on any computer with Lin or Win platform where you have connected concentrator via USB or otherwise. The most simply way is to connect concentrator via USB to your local PC and run Daemon here. Windows Developers We prepared IQRF Gateway Daemon Release for Win , please follow instruction how to install and start. Linux Developers Please install from packages as described in IQRF Gateway Daemon Documentation . After restart of your Linux machine Dameon will really run as \"Daemon\". WebSockets JSON API WebSockets port is opened during start o Daemon. The number of port is defined in IqrfDaemon\\runcfg\\iqrfgd2-WinCdc\\configuration\\iqrf__WebsocketMessaging.json . You can change it, but please do not forget to restart Daemon then. Html WebSocket example Open html page https://github.com/logimic/iqrfboard/blob/master/tools/index-1338.html Enter message: { \"mType\": \"iqrfEmbedLedg_Set\", \"data\": { \"msgId\": \"testEmbedLedr\", \"req\": { \"nAdr\": 0, \"param\": { \"onOff\": true } }, \"returnVerbose\": true } } Press Send in html page and see that this turned on the LED diod on concentrator module. Similar way you can turn LED off: { \"mType\": \"iqrfEmbedLedg_Set\", \"data\": { \"msgId\": \"testEmbedLedr\", \"req\": { \"nAdr\": 0, \"param\": { \"onOff\": false } }, \"returnVerbose\": true } } Similarly for other nodes by changing nAdr parameter indicating the node address. Full API description can be found here: https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html Python WebSocket example Install Python 3.6 Install pip install websockets Write simple program GreenLedOn.py # WS client example import asyncio import websockets import json x = { \"mType\": \"iqrfEmbedLedg_Set\", \"data\": { \"msgId\": \"testEmbedLedr\", \"req\": { \"nAdr\": 0, \"param\": { \"onOff\": True } }, \"returnVerbose\": False } } async def hello(): async with websockets.connect( 'ws://localhost:1338') as websocket: await websocket.send(json.dumps(x)) print(f\"Sent > {x}\") greeting = await websocket.recv() print(f\"Received < {greeting}\") asyncio.get_event_loop().run_until_complete(hello()) Run it $ py ./GreenLedOn.py and the green LED on coordinator turns on. Changing nAdr will address command to other node, the \"onOff\": False will turn LED off.","title":"IQRF Gateway Daemon"},{"location":"IqrfGatewayDaemon/#iqrf-gateway-daemon","text":"IQRF network is hidden behind coordinator connected to your computer via USB, SPI, UART or other types of interface. Communication between your program and coordinator is ensured via IQRF Gateway Daemon software module. This is Open Source gateway piece of software for communicating (sending and receiving JSON API messages) with IQRF network. This is included in many IQRF gateways and you can also download it and build for your platform.","title":"IQRF Gateway Daemon"},{"location":"IqrfGatewayDaemon/#links","text":"IQRF Gateway Daemon Sources IQRF Gateway Daemon Release for Win IQRF Gateway Daemon Documentation","title":"Links"},{"location":"IqrfGatewayDaemon/#run-daemon","text":"You can run Daemon on any computer with Lin or Win platform where you have connected concentrator via USB or otherwise. The most simply way is to connect concentrator via USB to your local PC and run Daemon here.","title":"Run Daemon"},{"location":"IqrfGatewayDaemon/#windows-developers","text":"We prepared IQRF Gateway Daemon Release for Win , please follow instruction how to install and start.","title":"Windows Developers"},{"location":"IqrfGatewayDaemon/#linux-developers","text":"Please install from packages as described in IQRF Gateway Daemon Documentation . After restart of your Linux machine Dameon will really run as \"Daemon\".","title":"Linux Developers"},{"location":"IqrfGatewayDaemon/#websockets-json-api","text":"WebSockets port is opened during start o Daemon. The number of port is defined in IqrfDaemon\\runcfg\\iqrfgd2-WinCdc\\configuration\\iqrf__WebsocketMessaging.json . You can change it, but please do not forget to restart Daemon then.","title":"WebSockets JSON API"},{"location":"IqrfGatewayDaemon/#html-websocket-example","text":"Open html page https://github.com/logimic/iqrfboard/blob/master/tools/index-1338.html Enter message: { \"mType\": \"iqrfEmbedLedg_Set\", \"data\": { \"msgId\": \"testEmbedLedr\", \"req\": { \"nAdr\": 0, \"param\": { \"onOff\": true } }, \"returnVerbose\": true } } Press Send in html page and see that this turned on the LED diod on concentrator module. Similar way you can turn LED off: { \"mType\": \"iqrfEmbedLedg_Set\", \"data\": { \"msgId\": \"testEmbedLedr\", \"req\": { \"nAdr\": 0, \"param\": { \"onOff\": false } }, \"returnVerbose\": true } } Similarly for other nodes by changing nAdr parameter indicating the node address. Full API description can be found here: https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html","title":"Html WebSocket example"},{"location":"IqrfGatewayDaemon/#python-websocket-example","text":"Install Python 3.6 Install pip install websockets Write simple program GreenLedOn.py # WS client example import asyncio import websockets import json x = { \"mType\": \"iqrfEmbedLedg_Set\", \"data\": { \"msgId\": \"testEmbedLedr\", \"req\": { \"nAdr\": 0, \"param\": { \"onOff\": True } }, \"returnVerbose\": False } } async def hello(): async with websockets.connect( 'ws://localhost:1338') as websocket: await websocket.send(json.dumps(x)) print(f\"Sent > {x}\") greeting = await websocket.recv() print(f\"Received < {greeting}\") asyncio.get_event_loop().run_until_complete(hello()) Run it $ py ./GreenLedOn.py and the green LED on coordinator turns on. Changing nAdr will address command to other node, the \"onOff\": False will turn LED off.","title":"Python WebSocket example"},{"location":"SetupIqrfNetwork/","text":"Setup IQRF Network You can get many pieces of information about IQRF at iqrf.org page. Simply said IQRF network is mesh kind of network working very well indoor and outdoor (up to 500m). It has one device as concentrator connected to gateway or your PC and the rest of devices are wireless nodes . The best start with IQRF is with their DS-START-04 development kit. It helps you to create your first IQRF network for testing purposes. In this tutorial we will show you how to create IQRF network with this kit. Links DS-START-04 development kit page IQRF Quick Start Guide IQRF Startup Package CK-USB-04A (programmer) DPA Framework on-line IQRF Standards IQRF Repository API Install IDE IDE is a basic programming tool for IQRF devices. Download and install https://www.iqrf.org/technology/iqrf-ide/iqrf-ide-gui Install IQRF Startup Package Download IQRF Startup package and unpack anywhere to your hard drive. First Start Start your IDE, navigate to your installed IQRF Startup package e.g. d:\\IQRF_OS403_7xD\\Examples\\DPA\\StartUp and open HWP-demo.iqrfprj Insert any IQRF module to programmer CK-USB-04A and connect to PC via USB. In IDE you will probably see USB device not connected in bottom panel. Go to menu Tools/USB Classes/Swith to Custom Device mode and select listed COM (USB) port. If you do not see any port please follow troubleshooting on IQRF support. You need driver update. Successful selection will show dialogue like this. Click Switch and the bottom panel will show Module ready - communication mode It might show dialogue about firmware update, then click Yes . Click Upload button, wait for firmware update, then press Close . Configure Coordinator A Concentrator is the node connected with PC or Gateway gathering data from all nodes. ! When you insert or remove TR from holder, always press SW2 button (nearer to SIM slot). It breaks power. In left panel check HWP-Coordinator-...iqrf file Double click on DPA-config.xml in left panel. Set items in dialogue as picture shows and click Upload button. In menu select Programming/Upload/Upload Selected Items . If the system complains that uploading version is not for the connected TR module, please upgrade OS in module. See Upgrade OS in TR module section. Configure Nodes A Node is a module communication within mesh with Concentrator. ! When you insert or remove TR from holder, always press SW2 button (nearer to SIM slot). It breaks power. Insert TR module to be node into programmer In left panel of IDE check HWP-Node-STD-... Keep the DPA-config.xml settings as previously at concentrator. Upload all your nodes. If the system complains that uploading version is not for the connected TR module, please upgrade OS in module. See Upgrade OS in TR module section. Upgrade OS in modules In menu select Tools/Change IQRF OS Wizard and follow wizard. Use SPI as upload method. Then select version to be uploaded !If your modules are older you might need to repeat the upgrade OS more times Run Network Insert coordinator configured TR module to programmer CK-USB-04A and nodes to other DK-EVAL-04A modules. In IDE in menu start Tools/IQMESH Network Manager and fill out the dialogue as shown (TX power, Auto address, ...). Then pres Clear All Bonds for remove any previous bonded modules. Red diods of modules are blinking. Then pres Bond Node and during bonding period press and hold SW1 button at one node until green red turns on. Repeat for each node. Now you should see two spots indicating successful bonding. Now click Discovery and spots are in blue. Switch in IDE to Map View and you should see node structure Click right mouse button on node 1 and select LED Red On Now you can see that the RED LED of node 1 is on. In similar way you can turn-off or play with LEDs. Send DPA messages Direct Peripheral Access (DPA) protocol is a simple byte-oriented protocol used to control nodes and network. Detail description of DPA Framework DPA can be sent via IDE. Open Terminal and click Set LEDR on which prefills data into Data to send fields. Change only NADR=0001 which indicates node 1 and click Send . This DPA command turned on RED diod on node 1. You can define any other DPA messages. Load Custom DPA Handler Custom DPA Handler is software routine which is executed within transceiver MCU and where you can put your customer code to modify. In IDE Project window you can see actually loaded CustomDpaHandler under Source item. Under Output HEX is its compiled code. You can click right mouse button above source of CustomDpaHandler-.. file and choose Build from menu for rebuilding of handler. You can load any other Custom DPA Handler from prepared set in IQRF SDK here: ./IQRF_OS403_7xD/Examples/DPA/CustomDpaHandlerExamples or you can modify any or write your own. Note: When you create your own handler, put it into CustomDpaHandlerExamples folder to be available others IQRF header files. Adding of your Custom DPA Handler: Right-click on any existing Custom DPA Handler under Source . From context menu select Add/Add Existing Item and select your CustomDpaHandler.c file. Make sure your handler is selected and via right-click select Build for its rebuild. You will see its compiled .hex state under Output Hex item. Right-click on the .hex file and select Upload . Now the handler will be uploaded to TR module. Then double-click on DPA-config.xml and in dialogue tick Custom DPA Handler and then Upload . Your own IQRF devices Now it's time to build your own IQRF device. The best start is with IQRFBB-10 development board from Logimic because it has many examples and you can reuse board layout and design for your later product development. Let's go with IQRFBB-10 board","title":"Setup IQRF Network"},{"location":"SetupIqrfNetwork/#setup-iqrf-network","text":"You can get many pieces of information about IQRF at iqrf.org page. Simply said IQRF network is mesh kind of network working very well indoor and outdoor (up to 500m). It has one device as concentrator connected to gateway or your PC and the rest of devices are wireless nodes . The best start with IQRF is with their DS-START-04 development kit. It helps you to create your first IQRF network for testing purposes. In this tutorial we will show you how to create IQRF network with this kit.","title":"Setup IQRF Network"},{"location":"SetupIqrfNetwork/#links","text":"DS-START-04 development kit page IQRF Quick Start Guide IQRF Startup Package CK-USB-04A (programmer) DPA Framework on-line IQRF Standards IQRF Repository API","title":"Links"},{"location":"SetupIqrfNetwork/#install-ide","text":"IDE is a basic programming tool for IQRF devices. Download and install https://www.iqrf.org/technology/iqrf-ide/iqrf-ide-gui","title":"Install IDE"},{"location":"SetupIqrfNetwork/#install-iqrf-startup-package","text":"Download IQRF Startup package and unpack anywhere to your hard drive.","title":"Install IQRF Startup Package"},{"location":"SetupIqrfNetwork/#first-start","text":"Start your IDE, navigate to your installed IQRF Startup package e.g. d:\\IQRF_OS403_7xD\\Examples\\DPA\\StartUp and open HWP-demo.iqrfprj Insert any IQRF module to programmer CK-USB-04A and connect to PC via USB. In IDE you will probably see USB device not connected in bottom panel. Go to menu Tools/USB Classes/Swith to Custom Device mode and select listed COM (USB) port. If you do not see any port please follow troubleshooting on IQRF support. You need driver update. Successful selection will show dialogue like this. Click Switch and the bottom panel will show Module ready - communication mode It might show dialogue about firmware update, then click Yes . Click Upload button, wait for firmware update, then press Close .","title":"First Start"},{"location":"SetupIqrfNetwork/#configure-coordinator","text":"A Concentrator is the node connected with PC or Gateway gathering data from all nodes. ! When you insert or remove TR from holder, always press SW2 button (nearer to SIM slot). It breaks power. In left panel check HWP-Coordinator-...iqrf file Double click on DPA-config.xml in left panel. Set items in dialogue as picture shows and click Upload button. In menu select Programming/Upload/Upload Selected Items . If the system complains that uploading version is not for the connected TR module, please upgrade OS in module. See Upgrade OS in TR module section.","title":"Configure Coordinator"},{"location":"SetupIqrfNetwork/#configure-nodes","text":"A Node is a module communication within mesh with Concentrator. ! When you insert or remove TR from holder, always press SW2 button (nearer to SIM slot). It breaks power. Insert TR module to be node into programmer In left panel of IDE check HWP-Node-STD-... Keep the DPA-config.xml settings as previously at concentrator. Upload all your nodes. If the system complains that uploading version is not for the connected TR module, please upgrade OS in module. See Upgrade OS in TR module section.","title":"Configure Nodes"},{"location":"SetupIqrfNetwork/#upgrade-os-in-modules","text":"In menu select Tools/Change IQRF OS Wizard and follow wizard. Use SPI as upload method. Then select version to be uploaded !If your modules are older you might need to repeat the upgrade OS more times","title":"Upgrade OS in modules"},{"location":"SetupIqrfNetwork/#run-network","text":"Insert coordinator configured TR module to programmer CK-USB-04A and nodes to other DK-EVAL-04A modules. In IDE in menu start Tools/IQMESH Network Manager and fill out the dialogue as shown (TX power, Auto address, ...). Then pres Clear All Bonds for remove any previous bonded modules. Red diods of modules are blinking. Then pres Bond Node and during bonding period press and hold SW1 button at one node until green red turns on. Repeat for each node. Now you should see two spots indicating successful bonding. Now click Discovery and spots are in blue. Switch in IDE to Map View and you should see node structure Click right mouse button on node 1 and select LED Red On Now you can see that the RED LED of node 1 is on. In similar way you can turn-off or play with LEDs.","title":"Run Network"},{"location":"SetupIqrfNetwork/#send-dpa-messages","text":"Direct Peripheral Access (DPA) protocol is a simple byte-oriented protocol used to control nodes and network. Detail description of DPA Framework DPA can be sent via IDE. Open Terminal and click Set LEDR on which prefills data into Data to send fields. Change only NADR=0001 which indicates node 1 and click Send . This DPA command turned on RED diod on node 1. You can define any other DPA messages.","title":"Send DPA messages"},{"location":"SetupIqrfNetwork/#load-custom-dpa-handler","text":"Custom DPA Handler is software routine which is executed within transceiver MCU and where you can put your customer code to modify. In IDE Project window you can see actually loaded CustomDpaHandler under Source item. Under Output HEX is its compiled code. You can click right mouse button above source of CustomDpaHandler-.. file and choose Build from menu for rebuilding of handler. You can load any other Custom DPA Handler from prepared set in IQRF SDK here: ./IQRF_OS403_7xD/Examples/DPA/CustomDpaHandlerExamples or you can modify any or write your own. Note: When you create your own handler, put it into CustomDpaHandlerExamples folder to be available others IQRF header files. Adding of your Custom DPA Handler: Right-click on any existing Custom DPA Handler under Source . From context menu select Add/Add Existing Item and select your CustomDpaHandler.c file. Make sure your handler is selected and via right-click select Build for its rebuild. You will see its compiled .hex state under Output Hex item. Right-click on the .hex file and select Upload . Now the handler will be uploaded to TR module. Then double-click on DPA-config.xml and in dialogue tick Custom DPA Handler and then Upload .","title":"Load Custom DPA Handler"},{"location":"SetupIqrfNetwork/#your-own-iqrf-devices","text":"Now it's time to build your own IQRF device. The best start is with IQRFBB-10 development board from Logimic because it has many examples and you can reuse board layout and design for your later product development. Let's go with IQRFBB-10 board","title":"Your own IQRF devices"},{"location":"examples/example-HTU21D/","text":"Temperature & Humidity Sensor This example shows how to connect HTU21D with the board and measure temperature and humidity. Links HTU21D Datasheet IQRFBB-10 Datasheet Prerequisities IQRFBB-10 bonded in working IQRF network. More in GettingStarted with IQRFBB-10 IQRF Gateway Daemon running. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python 3.6 WbSockets example Hardware wiring Fig. IQRFBB10 schema Fig. External LED wiring Software Custom DPA Handler We use Custom DPA Handler CustomDpaHandler-HTU21D-i2c.c in this repo. Copy the file into IQRF SDK folders and load to TR module as described here . // *********************************************************************************** // Custom DPA Handler code example - User peripheral implementation - i2c * // *********************************************************************************** // Copyright (c) Logimic, s.r.o. // // File: $RCSfile: CustomDpaHandler-HTU21D-i2c.c,v $ // Version: $Revision: 1.0 $ // Date: $Date: 2018/08/25 18:00:00 $ // // Revision history: // 2015/08/05 Release for DPA 3.02 // // ********************************************************************* // Online DPA documentation http://www.iqrf.org/DpaTechGuide/ // This example implements the user peripheral reading from HTU21D // PNUM = 0x20 and PCMD = 0 returns 2 bytes with result read from HTU21D // Based on example DDC-SE-01-i2c.c // Default IQRF include (modify the path according to your setup) #include \"IQRF.h\" // Default DPA header (modify the path according to your setup) #include \"DPA.h\" // Default Custom DPA Handler header (modify the path according to your setup) #include \"DPAcustomHandler.h\" //############################################################################################ void i2c_init(); void i2c_shutdown(); void i2c_waitForIdle(); void i2c_start(); void i2c_repStart(); void i2c_stop(); uns8 i2c_read( bit ack ); void i2c_write( uns8 i2cWriteData ); //#define I2C_ADR 0b10010110 #define I2C_ADR 0x40 #define PWR_SENSOR_TRIS TRISC.7 #define PWR_SENSOR_IO LATC.7 #define TRIGGER_TEMP_MEASUREMENT 0xE3 #define TRIGGER_WRITE 0x80 #define TRIGGER_READ 0x81 // Must be the 1st defined function in the source code in order to be placed at the correct FLASH location! //############################################################################################ bit CustomDpaHandler() //############################################################################################ { // Handler presence mark clrwdt(); // Detect DPA event to handle switch ( GetDpaEvent() ) { // ------------------------------------------------- case DpaEvent_Interrupt: // Do an extra quick background interrupt work // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible. // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one. // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the \ufffdempty\ufffd return handler ensures the shortest possible interrupt routine response time. // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy. // ! Make sure race condition does not occur when accessing those variables at other places. // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt. // ! Do not call any OS functions except setINDFx(). // ! Do not use any OS variables especially for writing access. // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage. DpaHandleReturnTRUE: return TRUE; // ------------------------------------------------- case DpaEvent_Init: // Do a one time initialization work before main loop starts case DpaEvent_AfterSleep: // Called after woken up after sleep i2c_init(); break; // ------------------------------------------------- case DpaEvent_BeforeSleep: // Called before going to sleep i2c_shutdown(); break; // ------------------------------------------------- case DpaEvent_DpaRequest: // Called to interpret DPA request for peripherals // ------------------------------------------------- // Peripheral enumeration if ( IsDpaEnumPeripheralsRequest() ) { // We implement 1 user peripheral _DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1; FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_USER + 0 ); _DpaMessage.EnumPeripheralsAnswer.HWPID = 0x000F; _DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0xAbCd; goto DpaHandleReturnTRUE; } // ------------------------------------------------- // Get information about peripheral else if ( IsDpaPeripheralInfoRequest() ) { if ( _PNUM == PNUM_USER + 0 ) { _DpaMessage.PeripheralInfoAnswer.PerT = PERIPHERAL_TYPE_USER_AREA; _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_READ; goto DpaHandleReturnTRUE; } break; } // ------------------------------------------------- else { // Handle peripheral command if ( _PNUM == PNUM_USER + 0 ) { // Check command switch ( _PCMD ) { case 0: // ------------------------------------------------- // Read temperature if ( _DpaDataLength != 0 ) DpaApiReturnPeripheralError( ERROR_DATA_LEN ); i2c_start(); i2c_write( TRIGGER_WRITE ); i2c_write( TRIGGER_TEMP_MEASUREMENT ); i2c_write( TRIGGER_READ ); i2c_stop(); waitMS ( 500 ); // wait for measurement i2c_start(); uns16 temperature @ _DpaMessage.Response.PData; temperature.high8 = i2c_read( TRUE ); // store the result temperature.low8 = i2c_read( TRUE ); i2c_stop(); _DpaDataLength = sizeof( temperature ); goto DpaHandleReturnTRUE; default: // ------------------------------------------------- // Invalid command DpaApiReturnPeripheralError( ERROR_PCMD ); } } } } return FALSE; } //############################################################################################ #pragma library 1 // Compile only used functions // ********************************************************************* void writeToSSPCON2( uns8 value @ param4.high8 ) { writeToRAM( &SSPCON2, value ); } //---------------------------------------------------------------------- void writeOredToSSPCON2( uns8 value @ param4.high8 ) { writeToSSPCON2( SSPCON2 | value ); } //---------------------------------------------------------------------- void i2c_init() { PORTC = 0x80; // port TRISC.3 = 1; // SCL as input (SIM C6) TRISC.4 = 1; // SDA as input (SIM C7) PWR_SENSOR_TRIS = 0; // sensor power as output (SIM C8) TRISC.5 = 1; // shared with SIM C8 TRISA.5 = 1; // sensor ALERT as input (SIM C5) TRISB.4 = 1; // shared with SIM C5 TRISC.6 = 1; // shared with SIM C5 writeToRAM( &SSPCON1, 0x38 ); // I2C master mode SSPCON = 0b00111000 writeToSSPCON2( 0x00 ); SSPADD = ( F_OSC / 50000 / 4 ) - 2; // 50 kHz SCL frequency SMP = 1; // Disable slew rate control } //------------------------------------------------------------------------ void i2c_shutdown() { writeToRAM( &SSPCON1, 0x00 ); // I2C master mode SSPCON = 0 } //------------------------------------------------------------------------ void i2c_waitForIdle() { while ( SSPCON2 & 0x1F ); // Wait for idle and not writing while ( RW_ ); // Wait for idle and not writing } //---------------------------------------------------------------------- void i2c_start() { i2c_waitForIdle(); writeOredToSSPCON2( 0x01 ); // SEN = 1 } //---------------------------------------------------------------------- void i2c_repStart() { i2c_waitForIdle(); writeOredToSSPCON2( 0x02 ); // RSEN = 1 } //---------------------------------------------------------------------- void i2c_stop() { i2c_waitForIdle(); writeOredToSSPCON2( 0x04 ); // PEN = 1 } //---------------------------------------------------------------------- uns8 i2c_read( bit ack ) { i2c_waitForIdle(); writeOredToSSPCON2( 0x08 ); // RCEN = 1 i2c_waitForIdle(); uns8 i2cReadData @ userReg0; i2cReadData = SSPBUF; i2c_waitForIdle(); if ( ack ) writeToSSPCON2( SSPCON2 & 0xDF ); // Acknowledge, ACKDT = 0 else writeOredToSSPCON2( 0x20 ); // Not acknowledge, ACKDT = 1 writeOredToSSPCON2( 0x10 ); // Send acknowledge sequence, ACKEN = 1 return i2cReadData; } //---------------------------------------------------------------------- void i2c_write( uns8 i2cWriteData @ param2 ) { i2c_waitForIdle(); SSPBUF = i2cWriteData; } // ############################################################################################ #pragma library 0 // Compile all //############################################################################################ // Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) #include \"DPAcustomHandler.h\" //############################################################################################ We use Custom DPA Handler CustomDpaHandler-HTU21D-i2c.c in this repo. Copy it into IQRF SDK folders and load to TR module as described here . Testing software: Tests user peripherial API JSON message We will use pure DPA messages handled via Daemon JSON API : RawHdp request v1-0-0 , ..example RawHdp response v1-0-0 , ..example DPA commands: NADR PNUM PCMD HWPID PDATA What XXXX 0x20 00 - Get user periphery status NADR: must be your address of IQRFBB-10 in IQRF network. Numbers in table are in hex format. Testing Software The example-HTU21D.py code: # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets example-ePir.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" GET_PERIPHERIAL = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 0x20, \"pCmd\": 0 }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: count = 0 while (count < 50): print (f\"The count is:{count}\") count = count + 1 # Read all pins await websocket.send(json.dumps(GET_PERIPHERIAL)) print(f\"Sent > {GET_PERIPHERIAL}\") response = await websocket.recv() print(f\"Received < {response}\") print(\"DONE....\") asyncio.get_event_loop().run_until_complete(hello())","title":"Temperature & Humidity Sensor"},{"location":"examples/example-HTU21D/#temperature-humidity-sensor","text":"This example shows how to connect HTU21D with the board and measure temperature and humidity.","title":"Temperature &amp; Humidity Sensor"},{"location":"examples/example-HTU21D/#links","text":"HTU21D Datasheet IQRFBB-10 Datasheet","title":"Links"},{"location":"examples/example-HTU21D/#prerequisities","text":"IQRFBB-10 bonded in working IQRF network. More in GettingStarted with IQRFBB-10 IQRF Gateway Daemon running. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python 3.6 WbSockets example","title":"Prerequisities"},{"location":"examples/example-HTU21D/#hardware-wiring","text":"Fig. IQRFBB10 schema Fig. External LED wiring","title":"Hardware wiring"},{"location":"examples/example-HTU21D/#software","text":"","title":"Software"},{"location":"examples/example-HTU21D/#custom-dpa-handler","text":"We use Custom DPA Handler CustomDpaHandler-HTU21D-i2c.c in this repo. Copy the file into IQRF SDK folders and load to TR module as described here . // *********************************************************************************** // Custom DPA Handler code example - User peripheral implementation - i2c * // *********************************************************************************** // Copyright (c) Logimic, s.r.o. // // File: $RCSfile: CustomDpaHandler-HTU21D-i2c.c,v $ // Version: $Revision: 1.0 $ // Date: $Date: 2018/08/25 18:00:00 $ // // Revision history: // 2015/08/05 Release for DPA 3.02 // // ********************************************************************* // Online DPA documentation http://www.iqrf.org/DpaTechGuide/ // This example implements the user peripheral reading from HTU21D // PNUM = 0x20 and PCMD = 0 returns 2 bytes with result read from HTU21D // Based on example DDC-SE-01-i2c.c // Default IQRF include (modify the path according to your setup) #include \"IQRF.h\" // Default DPA header (modify the path according to your setup) #include \"DPA.h\" // Default Custom DPA Handler header (modify the path according to your setup) #include \"DPAcustomHandler.h\" //############################################################################################ void i2c_init(); void i2c_shutdown(); void i2c_waitForIdle(); void i2c_start(); void i2c_repStart(); void i2c_stop(); uns8 i2c_read( bit ack ); void i2c_write( uns8 i2cWriteData ); //#define I2C_ADR 0b10010110 #define I2C_ADR 0x40 #define PWR_SENSOR_TRIS TRISC.7 #define PWR_SENSOR_IO LATC.7 #define TRIGGER_TEMP_MEASUREMENT 0xE3 #define TRIGGER_WRITE 0x80 #define TRIGGER_READ 0x81 // Must be the 1st defined function in the source code in order to be placed at the correct FLASH location! //############################################################################################ bit CustomDpaHandler() //############################################################################################ { // Handler presence mark clrwdt(); // Detect DPA event to handle switch ( GetDpaEvent() ) { // ------------------------------------------------- case DpaEvent_Interrupt: // Do an extra quick background interrupt work // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible. // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one. // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the \ufffdempty\ufffd return handler ensures the shortest possible interrupt routine response time. // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy. // ! Make sure race condition does not occur when accessing those variables at other places. // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt. // ! Do not call any OS functions except setINDFx(). // ! Do not use any OS variables especially for writing access. // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage. DpaHandleReturnTRUE: return TRUE; // ------------------------------------------------- case DpaEvent_Init: // Do a one time initialization work before main loop starts case DpaEvent_AfterSleep: // Called after woken up after sleep i2c_init(); break; // ------------------------------------------------- case DpaEvent_BeforeSleep: // Called before going to sleep i2c_shutdown(); break; // ------------------------------------------------- case DpaEvent_DpaRequest: // Called to interpret DPA request for peripherals // ------------------------------------------------- // Peripheral enumeration if ( IsDpaEnumPeripheralsRequest() ) { // We implement 1 user peripheral _DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1; FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_USER + 0 ); _DpaMessage.EnumPeripheralsAnswer.HWPID = 0x000F; _DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0xAbCd; goto DpaHandleReturnTRUE; } // ------------------------------------------------- // Get information about peripheral else if ( IsDpaPeripheralInfoRequest() ) { if ( _PNUM == PNUM_USER + 0 ) { _DpaMessage.PeripheralInfoAnswer.PerT = PERIPHERAL_TYPE_USER_AREA; _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_READ; goto DpaHandleReturnTRUE; } break; } // ------------------------------------------------- else { // Handle peripheral command if ( _PNUM == PNUM_USER + 0 ) { // Check command switch ( _PCMD ) { case 0: // ------------------------------------------------- // Read temperature if ( _DpaDataLength != 0 ) DpaApiReturnPeripheralError( ERROR_DATA_LEN ); i2c_start(); i2c_write( TRIGGER_WRITE ); i2c_write( TRIGGER_TEMP_MEASUREMENT ); i2c_write( TRIGGER_READ ); i2c_stop(); waitMS ( 500 ); // wait for measurement i2c_start(); uns16 temperature @ _DpaMessage.Response.PData; temperature.high8 = i2c_read( TRUE ); // store the result temperature.low8 = i2c_read( TRUE ); i2c_stop(); _DpaDataLength = sizeof( temperature ); goto DpaHandleReturnTRUE; default: // ------------------------------------------------- // Invalid command DpaApiReturnPeripheralError( ERROR_PCMD ); } } } } return FALSE; } //############################################################################################ #pragma library 1 // Compile only used functions // ********************************************************************* void writeToSSPCON2( uns8 value @ param4.high8 ) { writeToRAM( &SSPCON2, value ); } //---------------------------------------------------------------------- void writeOredToSSPCON2( uns8 value @ param4.high8 ) { writeToSSPCON2( SSPCON2 | value ); } //---------------------------------------------------------------------- void i2c_init() { PORTC = 0x80; // port TRISC.3 = 1; // SCL as input (SIM C6) TRISC.4 = 1; // SDA as input (SIM C7) PWR_SENSOR_TRIS = 0; // sensor power as output (SIM C8) TRISC.5 = 1; // shared with SIM C8 TRISA.5 = 1; // sensor ALERT as input (SIM C5) TRISB.4 = 1; // shared with SIM C5 TRISC.6 = 1; // shared with SIM C5 writeToRAM( &SSPCON1, 0x38 ); // I2C master mode SSPCON = 0b00111000 writeToSSPCON2( 0x00 ); SSPADD = ( F_OSC / 50000 / 4 ) - 2; // 50 kHz SCL frequency SMP = 1; // Disable slew rate control } //------------------------------------------------------------------------ void i2c_shutdown() { writeToRAM( &SSPCON1, 0x00 ); // I2C master mode SSPCON = 0 } //------------------------------------------------------------------------ void i2c_waitForIdle() { while ( SSPCON2 & 0x1F ); // Wait for idle and not writing while ( RW_ ); // Wait for idle and not writing } //---------------------------------------------------------------------- void i2c_start() { i2c_waitForIdle(); writeOredToSSPCON2( 0x01 ); // SEN = 1 } //---------------------------------------------------------------------- void i2c_repStart() { i2c_waitForIdle(); writeOredToSSPCON2( 0x02 ); // RSEN = 1 } //---------------------------------------------------------------------- void i2c_stop() { i2c_waitForIdle(); writeOredToSSPCON2( 0x04 ); // PEN = 1 } //---------------------------------------------------------------------- uns8 i2c_read( bit ack ) { i2c_waitForIdle(); writeOredToSSPCON2( 0x08 ); // RCEN = 1 i2c_waitForIdle(); uns8 i2cReadData @ userReg0; i2cReadData = SSPBUF; i2c_waitForIdle(); if ( ack ) writeToSSPCON2( SSPCON2 & 0xDF ); // Acknowledge, ACKDT = 0 else writeOredToSSPCON2( 0x20 ); // Not acknowledge, ACKDT = 1 writeOredToSSPCON2( 0x10 ); // Send acknowledge sequence, ACKEN = 1 return i2cReadData; } //---------------------------------------------------------------------- void i2c_write( uns8 i2cWriteData @ param2 ) { i2c_waitForIdle(); SSPBUF = i2cWriteData; } // ############################################################################################ #pragma library 0 // Compile all //############################################################################################ // Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) #include \"DPAcustomHandler.h\" //############################################################################################ We use Custom DPA Handler CustomDpaHandler-HTU21D-i2c.c in this repo. Copy it into IQRF SDK folders and load to TR module as described here . Testing software: Tests user peripherial","title":"Custom DPA Handler"},{"location":"examples/example-HTU21D/#api-json-message","text":"We will use pure DPA messages handled via Daemon JSON API : RawHdp request v1-0-0 , ..example RawHdp response v1-0-0 , ..example DPA commands: NADR PNUM PCMD HWPID PDATA What XXXX 0x20 00 - Get user periphery status NADR: must be your address of IQRFBB-10 in IQRF network. Numbers in table are in hex format.","title":"API JSON message"},{"location":"examples/example-HTU21D/#testing-software","text":"The example-HTU21D.py code: # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets example-ePir.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" GET_PERIPHERIAL = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 0x20, \"pCmd\": 0 }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: count = 0 while (count < 50): print (f\"The count is:{count}\") count = count + 1 # Read all pins await websocket.send(json.dumps(GET_PERIPHERIAL)) print(f\"Sent > {GET_PERIPHERIAL}\") response = await websocket.recv() print(f\"Received < {response}\") print(\"DONE....\") asyncio.get_event_loop().run_until_complete(hello())","title":"Testing Software"},{"location":"examples/example-bistable-relay/","text":"Bi-stable relay This example turns bistable relay on/off. Links IQRFBB-10 Datasheet Prerequisities IQRFBB-10 bonded in working IQRF network. More in GettingStarted with IQRFBB-10 IQRF Gateway Daemon running. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python 3.6 WbSockets example Hardware wiring No hardware wiring needed, bistable relay is managed via C1 and C2 signals. See. Documentation Software We use Standard DPA handler already loaded in board TR module. Testing software: Set EQ14 as DO. EQ14 is Q14/C1/RA0 pin on TR-76DA. Set EQ15 as DO. EQ15 is Q15/C2/RC2 pin on TR-76DA. Set C2=LO, C1=HI Wait 3secs Set C2=HI, C1=LO API JSON message We will use pure DPA messages handled via Daemon JSON API : RawHdp request v1-0-0 , ..example RawHdp response v1-0-0 , ..example DPA commands: NADR PNUM PCMD HWPID PDATA What XXXX 09 00 - 00.01.00 Set C1 Output XXXX 09 00 - 02.04.00 Set C2 Output XXXX 09 01 - 00.01.01 Set C1 ON XXXX 09 01 - 00.01.00 Set C1 OFF XXXX 09 01 - 02.04.04 Set C2 ON XXXX 09 01 - 02.04.00 Set C2 OFF NADR: must be your address of IQRFBB-10 in IQRF network. Numbers in table are in hex format. Testing Software The example-bistable-relay.py script. # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets example-bistable-relay.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" C1_OUT = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 0, \"pData\": [0, 1, 0] }, \"returnVerbose\": True } } C1_ON = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 1, \"pData\": [0, 1, 1] }, \"returnVerbose\": True } } C1_OFF = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 1, \"pData\": [0, 1, 0] }, \"returnVerbose\": True } } C2_OUT = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 0, \"pData\": [2, 4, 0] }, \"returnVerbose\": True } } C2_ON = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 1, \"pData\": [2, 4, 4] }, \"returnVerbose\": True } } C2_OFF = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 1, \"pData\": [2, 4, 0] }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: # Set C1 OUT await websocket.send(json.dumps(C1_OUT)) print(f\"Sent > {C1_OUT}\") response = await websocket.recv() print(f\"Received < {response}\") # Set C2 OUT await websocket.send(json.dumps(C2_OUT)) print(f\"Sent > {C2_OUT}\") response = await websocket.recv() print(f\"Received < {response}\") # Set C2 OFF await websocket.send(json.dumps(C2_OFF)) print(f\"Sent > {C2_OFF}\") response = await websocket.recv() print(f\"Received < {response}\") # Set C1 ON await websocket.send(json.dumps(C1_ON)) print(f\"Sent > {C1_ON}\") response = await websocket.recv() print(f\"Received < {response}\") print(\"Waiting 3 secs then reswitch...\") # Wait 3 sec time.sleep(3) # Set C1 OFF await websocket.send(json.dumps(C1_OFF)) print(f\"Sent > {C1_OFF}\") response = await websocket.recv() print(f\"Received < {response}\") # Set C2 ON await websocket.send(json.dumps(C2_ON)) print(f\"Sent > {C1_ON}\") response = await websocket.recv() print(f\"Received < {response}\") asyncio.get_event_loop().run_until_complete(hello())","title":"Bi-stable relay"},{"location":"examples/example-bistable-relay/#bi-stable-relay","text":"This example turns bistable relay on/off.","title":"Bi-stable relay"},{"location":"examples/example-bistable-relay/#links","text":"IQRFBB-10 Datasheet","title":"Links"},{"location":"examples/example-bistable-relay/#prerequisities","text":"IQRFBB-10 bonded in working IQRF network. More in GettingStarted with IQRFBB-10 IQRF Gateway Daemon running. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python 3.6 WbSockets example","title":"Prerequisities"},{"location":"examples/example-bistable-relay/#hardware-wiring","text":"No hardware wiring needed, bistable relay is managed via C1 and C2 signals. See. Documentation","title":"Hardware wiring"},{"location":"examples/example-bistable-relay/#software","text":"We use Standard DPA handler already loaded in board TR module. Testing software: Set EQ14 as DO. EQ14 is Q14/C1/RA0 pin on TR-76DA. Set EQ15 as DO. EQ15 is Q15/C2/RC2 pin on TR-76DA. Set C2=LO, C1=HI Wait 3secs Set C2=HI, C1=LO","title":"Software"},{"location":"examples/example-bistable-relay/#api-json-message","text":"We will use pure DPA messages handled via Daemon JSON API : RawHdp request v1-0-0 , ..example RawHdp response v1-0-0 , ..example DPA commands: NADR PNUM PCMD HWPID PDATA What XXXX 09 00 - 00.01.00 Set C1 Output XXXX 09 00 - 02.04.00 Set C2 Output XXXX 09 01 - 00.01.01 Set C1 ON XXXX 09 01 - 00.01.00 Set C1 OFF XXXX 09 01 - 02.04.04 Set C2 ON XXXX 09 01 - 02.04.00 Set C2 OFF NADR: must be your address of IQRFBB-10 in IQRF network. Numbers in table are in hex format.","title":"API JSON message"},{"location":"examples/example-bistable-relay/#testing-software","text":"The example-bistable-relay.py script. # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets example-bistable-relay.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" C1_OUT = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 0, \"pData\": [0, 1, 0] }, \"returnVerbose\": True } } C1_ON = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 1, \"pData\": [0, 1, 1] }, \"returnVerbose\": True } } C1_OFF = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 1, \"pData\": [0, 1, 0] }, \"returnVerbose\": True } } C2_OUT = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 0, \"pData\": [2, 4, 0] }, \"returnVerbose\": True } } C2_ON = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 1, \"pData\": [2, 4, 4] }, \"returnVerbose\": True } } C2_OFF = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 1, \"pData\": [2, 4, 0] }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: # Set C1 OUT await websocket.send(json.dumps(C1_OUT)) print(f\"Sent > {C1_OUT}\") response = await websocket.recv() print(f\"Received < {response}\") # Set C2 OUT await websocket.send(json.dumps(C2_OUT)) print(f\"Sent > {C2_OUT}\") response = await websocket.recv() print(f\"Received < {response}\") # Set C2 OFF await websocket.send(json.dumps(C2_OFF)) print(f\"Sent > {C2_OFF}\") response = await websocket.recv() print(f\"Received < {response}\") # Set C1 ON await websocket.send(json.dumps(C1_ON)) print(f\"Sent > {C1_ON}\") response = await websocket.recv() print(f\"Received < {response}\") print(\"Waiting 3 secs then reswitch...\") # Wait 3 sec time.sleep(3) # Set C1 OFF await websocket.send(json.dumps(C1_OFF)) print(f\"Sent > {C1_OFF}\") response = await websocket.recv() print(f\"Received < {response}\") # Set C2 ON await websocket.send(json.dumps(C2_ON)) print(f\"Sent > {C1_ON}\") response = await websocket.recv() print(f\"Received < {response}\") asyncio.get_event_loop().run_until_complete(hello())","title":"Testing Software"},{"location":"examples/example-di/","text":"Digital Input This example shows how to detect DI on board. We will detect connection EQ13 pin to GRND. DI status is tested by testing software via reading all inputs. Links IQRFBB-10 Datasheet Prerequisities IQRFBB-10 bonded in working IQRF network. More in GettingStarted with IQRFBB-10 IQRF Gateway Daemon running. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python 3.6 WbSockets example Hardware wiring Fig.: IQRFBB10 schema Fig.: External LED wiring Connect EQ13 and GRND pins via button. Software We use Standard DPA handler already loaded in board TR module. Testing software: Set EQ13 as DI. EQ13 is Q13/RE3 pin on TR-76DA. Ask user to press an hold button Wait 3sec Read all DI Parse response and make decision API JSON message We will use pure DPA messages handled via Daemon JSON API : RawHdp request v1-0-0 , ..example RawHdp response v1-0-0 , ..example DPA commands: NADR PNUM PCMD HWPID PDATA What XXXX 09 00 FFFF 10.08.08 Set RE3 (Address E3) as DI XXXX 09 02 FFFF Read all DI pins NADR: must be your address of IQRFBB-10 in IQRF network. Numbers in table are in hex format. Testing Software The example-di.py code: # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets example-di.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" EQ13_IN = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 0, \"pData\": [16, 8, 8] }, \"returnVerbose\": True } } READ_ALL = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 2 }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: # Set C1 OUT await websocket.send(json.dumps(EQ13_IN)) print(f\"Sent > {EQ13_IN}\") response = await websocket.recv() print(f\"Received < {response}\") # Read all pins await websocket.send(json.dumps(READ_ALL)) print(f\"Sent > {READ_ALL}\") response = await websocket.recv() print(f\"Received < {response}\") print(\"Connect EQ13 to GND...\") # Wait 2 sec time.sleep(3) # Read all pins again await websocket.send(json.dumps(READ_ALL)) print(f\"Sent > {READ_ALL}\") response = await websocket.recv() print(f\"Received < {response}\") # Parse JSON response data = json.loads(response) pData = data[\"data\"][\"rsp\"][\"pData\"] button = pData[4] # Check input detection if button == 8: print(f\"Input NOT detected: {button}\") else: print(f\"!!!Input detected: {button}\") asyncio.get_event_loop().run_until_complete(hello())","title":"Digital Input"},{"location":"examples/example-di/#digital-input","text":"This example shows how to detect DI on board. We will detect connection EQ13 pin to GRND. DI status is tested by testing software via reading all inputs.","title":"Digital Input"},{"location":"examples/example-di/#links","text":"IQRFBB-10 Datasheet","title":"Links"},{"location":"examples/example-di/#prerequisities","text":"IQRFBB-10 bonded in working IQRF network. More in GettingStarted with IQRFBB-10 IQRF Gateway Daemon running. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python 3.6 WbSockets example","title":"Prerequisities"},{"location":"examples/example-di/#hardware-wiring","text":"Fig.: IQRFBB10 schema Fig.: External LED wiring Connect EQ13 and GRND pins via button.","title":"Hardware wiring"},{"location":"examples/example-di/#software","text":"We use Standard DPA handler already loaded in board TR module. Testing software: Set EQ13 as DI. EQ13 is Q13/RE3 pin on TR-76DA. Ask user to press an hold button Wait 3sec Read all DI Parse response and make decision","title":"Software"},{"location":"examples/example-di/#api-json-message","text":"We will use pure DPA messages handled via Daemon JSON API : RawHdp request v1-0-0 , ..example RawHdp response v1-0-0 , ..example DPA commands: NADR PNUM PCMD HWPID PDATA What XXXX 09 00 FFFF 10.08.08 Set RE3 (Address E3) as DI XXXX 09 02 FFFF Read all DI pins NADR: must be your address of IQRFBB-10 in IQRF network. Numbers in table are in hex format.","title":"API JSON message"},{"location":"examples/example-di/#testing-software","text":"The example-di.py code: # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets example-di.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" EQ13_IN = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 0, \"pData\": [16, 8, 8] }, \"returnVerbose\": True } } READ_ALL = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 2 }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: # Set C1 OUT await websocket.send(json.dumps(EQ13_IN)) print(f\"Sent > {EQ13_IN}\") response = await websocket.recv() print(f\"Received < {response}\") # Read all pins await websocket.send(json.dumps(READ_ALL)) print(f\"Sent > {READ_ALL}\") response = await websocket.recv() print(f\"Received < {response}\") print(\"Connect EQ13 to GND...\") # Wait 2 sec time.sleep(3) # Read all pins again await websocket.send(json.dumps(READ_ALL)) print(f\"Sent > {READ_ALL}\") response = await websocket.recv() print(f\"Received < {response}\") # Parse JSON response data = json.loads(response) pData = data[\"data\"][\"rsp\"][\"pData\"] button = pData[4] # Check input detection if button == 8: print(f\"Input NOT detected: {button}\") else: print(f\"!!!Input detected: {button}\") asyncio.get_event_loop().run_until_complete(hello())","title":"Testing Software"},{"location":"examples/example-do/","text":"Digital Output This example shows how to set EQ6 (X10 SCL) pin of the board. Links IQRFBB-10 Datasheet IQRF Gateway Daemon Documentation Prerequisities IQRFBB-10 bonded in working IQRF network. More in Getting Started IQRF Gateway Daemon working. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python WebSockets example Hardware wiring Fig.: IQRFBB10 schema Fig.: External LED wiring Connect SCL and GRN pins via button. Software We use Standard DPA handler already loaded in board TR module. Testing software: Set EQ6 (X10 SCL) as DO. EQ6 is Q6, C6/RC3 genral I/O pin on TR-76DA. Set pin HI Wait 3sec Set pin LO API JSON message We will use DPA messages handled via Daemon JSON API : RawHdp request v1-0-0 , ..example RawHdp response v1-0-0 , ..example DPA commands: NADR PNUM PCMD HWPID PDATA What XXXX 09 00 FFFF 02.08.00 Set RC3 (Address C3) as D0 XXXX 09 01 FFFF 02.08.08 Set pin HI XXXX 09 01 FFFF 02.08.00 Set pin LO NADR: must be your address of IQRFBB-10 in IQRF network. Numbers in table are in hex format. Testing Software The example-di.py code: # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets example-do.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" RC3_OUT = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 0, \"pData\": [2, 8, 0] }, \"returnVerbose\": True } } RC3_ON = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 1, \"pData\": [2, 8, 8] }, \"returnVerbose\": True } } RC3_OFF = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 1, \"pData\": [2, 8, 0] }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: # Set RC3 OUT await websocket.send(json.dumps(RC3_OUT)) print(f\"Sent > {RC3_OUT}\") response = await websocket.recv() print(f\"Received < {response}\") # Set RC3 ON await websocket.send(json.dumps(RC3_ON)) print(f\"Sent > {RC3_ON}\") response = await websocket.recv() print(f\"Received < {response}\") print(\"RC3 power ON...\") # Wait 2 sec time.sleep(3) # Read all pins await websocket.send(json.dumps(RC3_OFF)) print(f\"Sent > {RC3_OFF}\") response = await websocket.recv() print(f\"Received < {response}\") asyncio.get_event_loop().run_until_complete(hello())","title":"Digital Output"},{"location":"examples/example-do/#digital-output","text":"This example shows how to set EQ6 (X10 SCL) pin of the board.","title":"Digital Output"},{"location":"examples/example-do/#links","text":"IQRFBB-10 Datasheet IQRF Gateway Daemon Documentation","title":"Links"},{"location":"examples/example-do/#prerequisities","text":"IQRFBB-10 bonded in working IQRF network. More in Getting Started IQRF Gateway Daemon working. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python WebSockets example","title":"Prerequisities"},{"location":"examples/example-do/#hardware-wiring","text":"Fig.: IQRFBB10 schema Fig.: External LED wiring Connect SCL and GRN pins via button.","title":"Hardware wiring"},{"location":"examples/example-do/#software","text":"We use Standard DPA handler already loaded in board TR module. Testing software: Set EQ6 (X10 SCL) as DO. EQ6 is Q6, C6/RC3 genral I/O pin on TR-76DA. Set pin HI Wait 3sec Set pin LO","title":"Software"},{"location":"examples/example-do/#api-json-message","text":"We will use DPA messages handled via Daemon JSON API : RawHdp request v1-0-0 , ..example RawHdp response v1-0-0 , ..example DPA commands: NADR PNUM PCMD HWPID PDATA What XXXX 09 00 FFFF 02.08.00 Set RC3 (Address C3) as D0 XXXX 09 01 FFFF 02.08.08 Set pin HI XXXX 09 01 FFFF 02.08.00 Set pin LO NADR: must be your address of IQRFBB-10 in IQRF network. Numbers in table are in hex format.","title":"API JSON message"},{"location":"examples/example-do/#testing-software","text":"The example-di.py code: # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets example-do.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" RC3_OUT = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 0, \"pData\": [2, 8, 0] }, \"returnVerbose\": True } } RC3_ON = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 1, \"pData\": [2, 8, 8] }, \"returnVerbose\": True } } RC3_OFF = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 1, \"pData\": [2, 8, 0] }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: # Set RC3 OUT await websocket.send(json.dumps(RC3_OUT)) print(f\"Sent > {RC3_OUT}\") response = await websocket.recv() print(f\"Received < {response}\") # Set RC3 ON await websocket.send(json.dumps(RC3_ON)) print(f\"Sent > {RC3_ON}\") response = await websocket.recv() print(f\"Received < {response}\") print(\"RC3 power ON...\") # Wait 2 sec time.sleep(3) # Read all pins await websocket.send(json.dumps(RC3_OFF)) print(f\"Sent > {RC3_OFF}\") response = await websocket.recv() print(f\"Received < {response}\") asyncio.get_event_loop().run_until_complete(hello())","title":"Testing Software"},{"location":"examples/example-ePir/","text":"Motion Sensor (ePir) This example shows how to connect Zilog ePIR \u2013 SparkFub \u2013 SEN-09587 to the board. Links IQRFBB-10 Datasheet Prerequisities IQRFBB-10 bonded in working IQRF network. More in GettingStarted with IQRFBB-10 IQRF Gateway Daemon running. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python 3.6 WbSockets example Hardware wiring Fig.: IQRFBB10 schema Fig.: External LED wiring Connect VO, EQ13 and GRND pins with Zilog ePIR \u2013 SparkFub \u2013 SEN-09587 . Software We use Standard DPA handler already loaded in board TR module. Testing software: Set EQ13 as DI. EQ13 is Q13/RE3 pin on TR-76DA. Read all DI in the loop Parse response and make decision API JSON message We will use pure DPA messages handled via Daemon JSON API : RawHdp request v1-0-0 , ..example RawHdp response v1-0-0 , ..example DPA commands: NADR PNUM PCMD HWPID PDATA What XXXX 09 00 FFFF 10.08.08 Set RE3 (Address E3) as DI XXXX 09 02 FFFF Read all DI pins NADR: must be your address of IQRFBB-10 in IQRF network. Numbers in table are in hex format. Testing Software The example-ePir.py code: # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets example-ePir.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" EQ13_IN = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 0, \"pData\": [16, 8, 8] }, \"returnVerbose\": True } } READ_ALL = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 2 }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: # Set EQ13 IN await websocket.send(json.dumps(EQ13_IN)) print(f\"Sent > {EQ13_IN}\") response = await websocket.recv() print(f\"Received < {response}\") count = 0 detected = False while (count < 20 and detected == False): print (f\"The count is:{count}\") count = count + 1 # Read all pins await websocket.send(json.dumps(READ_ALL)) print(f\"Sent > {READ_ALL}\") response = await websocket.recv() print(f\"Received < {response}\") # Parse JSON response data = json.loads(response) pData = data[\"data\"][\"rsp\"][\"pData\"] button = pData[4] # Check input detection if button == 0: detected = True # Check input detection if detected == False: print(f\"NOTHING detected :(\") else: print(f\"Motion detected!!! :)\") asyncio.get_event_loop().run_until_complete(hello())","title":"Motion Sensor (ePir)"},{"location":"examples/example-ePir/#motion-sensor-epir","text":"This example shows how to connect Zilog ePIR \u2013 SparkFub \u2013 SEN-09587 to the board.","title":"Motion Sensor (ePir)"},{"location":"examples/example-ePir/#links","text":"IQRFBB-10 Datasheet","title":"Links"},{"location":"examples/example-ePir/#prerequisities","text":"IQRFBB-10 bonded in working IQRF network. More in GettingStarted with IQRFBB-10 IQRF Gateway Daemon running. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python 3.6 WbSockets example","title":"Prerequisities"},{"location":"examples/example-ePir/#hardware-wiring","text":"Fig.: IQRFBB10 schema Fig.: External LED wiring Connect VO, EQ13 and GRND pins with Zilog ePIR \u2013 SparkFub \u2013 SEN-09587 .","title":"Hardware wiring"},{"location":"examples/example-ePir/#software","text":"We use Standard DPA handler already loaded in board TR module. Testing software: Set EQ13 as DI. EQ13 is Q13/RE3 pin on TR-76DA. Read all DI in the loop Parse response and make decision","title":"Software"},{"location":"examples/example-ePir/#api-json-message","text":"We will use pure DPA messages handled via Daemon JSON API : RawHdp request v1-0-0 , ..example RawHdp response v1-0-0 , ..example DPA commands: NADR PNUM PCMD HWPID PDATA What XXXX 09 00 FFFF 10.08.08 Set RE3 (Address E3) as DI XXXX 09 02 FFFF Read all DI pins NADR: must be your address of IQRFBB-10 in IQRF network. Numbers in table are in hex format.","title":"API JSON message"},{"location":"examples/example-ePir/#testing-software","text":"The example-ePir.py code: # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets example-ePir.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" EQ13_IN = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 0, \"pData\": [16, 8, 8] }, \"returnVerbose\": True } } READ_ALL = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 2 }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: # Set EQ13 IN await websocket.send(json.dumps(EQ13_IN)) print(f\"Sent > {EQ13_IN}\") response = await websocket.recv() print(f\"Received < {response}\") count = 0 detected = False while (count < 20 and detected == False): print (f\"The count is:{count}\") count = count + 1 # Read all pins await websocket.send(json.dumps(READ_ALL)) print(f\"Sent > {READ_ALL}\") response = await websocket.recv() print(f\"Received < {response}\") # Parse JSON response data = json.loads(response) pData = data[\"data\"][\"rsp\"][\"pData\"] button = pData[4] # Check input detection if button == 0: detected = True # Check input detection if detected == False: print(f\"NOTHING detected :(\") else: print(f\"Motion detected!!! :)\") asyncio.get_event_loop().run_until_complete(hello())","title":"Testing Software"},{"location":"examples/example-hall/","text":"Hall Magnetic Sensor This example shows how to connect KS0020 Hall Magnetic Sensor with the board. Links IQRFBB-10 Datasheet Prerequisities IQRFBB-10 bonded in working IQRF network. More in GettingStarted with IQRFBB-10 IQRF Gateway Daemon running. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python 3.6 WbSockets example Hardware wiring Fig.: IQRFBB10 schema Fig.: External LED wiring Connect VO, EQ13 and GRND pins with KS0020 Keyestudio Hall Magnetic Sensor . Software We use Standard DPA handler already loaded in board TR module. Testing software: Set EQ13 as DI. EQ13 is Q13/RE3 pin on TR-76DA. Read all DI in the loop Parse response and make decision API JSON message We will use pure DPA messages handled via Daemon JSON API : RawHdp request v1-0-0 , ..example RawHdp response v1-0-0 , ..example DPA commands: NADR PNUM PCMD HWPID PDATA What XXXX 09 00 FFFF 10.08.08 Set RE3 (Address E3) as DI XXXX 09 02 FFFF Read all DI pins NADR: must be your address of IQRFBB-10 in IQRF network. Numbers in table are in hex format. Testing Software The example-di.py code: # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets example-hall.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" EQ13_IN = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 0, \"pData\": [16, 8, 8] }, \"returnVerbose\": True } } READ_ALL = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 2 }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: # Set EQ13 IN await websocket.send(json.dumps(EQ13_IN)) print(f\"Sent > {EQ13_IN}\") response = await websocket.recv() print(f\"Received < {response}\") count = 0 detected = False while (count < 20 and detected == False): print (f\"The count is:{count}\") count = count + 1 # Read all pins await websocket.send(json.dumps(READ_ALL)) print(f\"Sent > {READ_ALL}\") response = await websocket.recv() print(f\"Received < {response}\") # Parse JSON response data = json.loads(response) pData = data[\"data\"][\"rsp\"][\"pData\"] button = pData[4] # Check input detection if button == 0: detected = True # Check input detection if detected == False: print(f\"NOTHING detected :(\") else: print(f\"Input detected!!! :)\") asyncio.get_event_loop().run_until_complete(hello())","title":"Hall Magnetic Sensor"},{"location":"examples/example-hall/#hall-magnetic-sensor","text":"This example shows how to connect KS0020 Hall Magnetic Sensor with the board.","title":"Hall Magnetic Sensor"},{"location":"examples/example-hall/#links","text":"IQRFBB-10 Datasheet","title":"Links"},{"location":"examples/example-hall/#prerequisities","text":"IQRFBB-10 bonded in working IQRF network. More in GettingStarted with IQRFBB-10 IQRF Gateway Daemon running. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python 3.6 WbSockets example","title":"Prerequisities"},{"location":"examples/example-hall/#hardware-wiring","text":"Fig.: IQRFBB10 schema Fig.: External LED wiring Connect VO, EQ13 and GRND pins with KS0020 Keyestudio Hall Magnetic Sensor .","title":"Hardware wiring"},{"location":"examples/example-hall/#software","text":"We use Standard DPA handler already loaded in board TR module. Testing software: Set EQ13 as DI. EQ13 is Q13/RE3 pin on TR-76DA. Read all DI in the loop Parse response and make decision","title":"Software"},{"location":"examples/example-hall/#api-json-message","text":"We will use pure DPA messages handled via Daemon JSON API : RawHdp request v1-0-0 , ..example RawHdp response v1-0-0 , ..example DPA commands: NADR PNUM PCMD HWPID PDATA What XXXX 09 00 FFFF 10.08.08 Set RE3 (Address E3) as DI XXXX 09 02 FFFF Read all DI pins NADR: must be your address of IQRFBB-10 in IQRF network. Numbers in table are in hex format.","title":"API JSON message"},{"location":"examples/example-hall/#testing-software","text":"The example-di.py code: # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets example-hall.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" EQ13_IN = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 0, \"pData\": [16, 8, 8] }, \"returnVerbose\": True } } READ_ALL = { \"mType\": \"iqrfRawHdp\", \"data\": { \"msgId\": \"testRawHdp\", \"req\": { \"nAdr\": boardAddr, \"pNum\": 9, \"pCmd\": 2 }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: # Set EQ13 IN await websocket.send(json.dumps(EQ13_IN)) print(f\"Sent > {EQ13_IN}\") response = await websocket.recv() print(f\"Received < {response}\") count = 0 detected = False while (count < 20 and detected == False): print (f\"The count is:{count}\") count = count + 1 # Read all pins await websocket.send(json.dumps(READ_ALL)) print(f\"Sent > {READ_ALL}\") response = await websocket.recv() print(f\"Received < {response}\") # Parse JSON response data = json.loads(response) pData = data[\"data\"][\"rsp\"][\"pData\"] button = pData[4] # Check input detection if button == 0: detected = True # Check input detection if detected == False: print(f\"NOTHING detected :(\") else: print(f\"Input detected!!! :)\") asyncio.get_event_loop().run_until_complete(hello())","title":"Testing Software"},{"location":"examples/example-led23/","text":"Set LED2, LED3 on/off This example turns RED LED on, waits 2 seconds, then turns RED LED off and GREEN LED on, then after 2 seconds turns GREEN LED off. Links IQRFBB-10 Datasheet IQRF Gateway Daemon Documentation Prerequisities IQRFBB-10 bonded in working IQRF network. More in Getting Started IQRF Gateway Daemon working. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python WebSockets example Hardware wiring No hardware wiring needed, both LED2 and LED3 are mounted on the board and connected to C1 and C2. Software A. Embedded JSON messages We use standard DPA handler already loaded in board TR module. API JSON message We can manage diods via sending Daemon JSON API messages. LD2 (Green DIOD) ON/OFF Set LEDG request v1-0-0 , ..example Set LEDG response v1-0-0 , ..example LD3 (Red DIOD) ON/OFF Set LEDR request v1-0-0 , ..example Set LEDR response v1-0-0 , ..example Testing Software The example-led23.py script also prints sent and received JSON messages. Note: Parameter boardAddr must be IQRFBB-10 node address in IQRF network. # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets example-led23.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" LEDR_ON = { \"mType\": \"iqrfEmbedLedr_Set\", \"data\": { \"msgId\": \"testEmbedLedr\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"onOff\": True } }, \"returnVerbose\": True } } LEDR_OFF = { \"mType\": \"iqrfEmbedLedr_Set\", \"data\": { \"msgId\": \"testEmbedLedr\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"onOff\": False } }, \"returnVerbose\": True } } LEDG_ON = { \"mType\": \"iqrfEmbedLedg_Set\", \"data\": { \"msgId\": \"testEmbedLedr\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"onOff\": True } }, \"returnVerbose\": True } } LEDG_OFF = { \"mType\": \"iqrfEmbedLedg_Set\", \"data\": { \"msgId\": \"testEmbedLedr\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"onOff\": False } }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: # RED LED ON await websocket.send(json.dumps(LEDR_ON)) print(f\"Sent > {LEDR_ON}\") response = await websocket.recv() print(f\"Received < {response}\") # Wait 2 sec time.sleep(2) # RED LED OFF await websocket.send(json.dumps(LEDR_OFF)) print(f\"Sent > {LEDR_OFF}\") response = await websocket.recv() print(f\"Received < {response}\") # GREEN LED ON await websocket.send(json.dumps(LEDG_ON)) print(f\"Sent > {LEDG_ON}\") response = await websocket.recv() print(f\"Received < {response}\") # Wait 2 sec time.sleep(2) # GREEN LED OFF await websocket.send(json.dumps(LEDG_OFF)) print(f\"Sent > {LEDG_OFF}\") response = await websocket.recv() print(f\"Received < {response}\") asyncio.get_event_loop().run_until_complete(hello())","title":"Set LED2, LED3 on/off"},{"location":"examples/example-led23/#set-led2-led3-onoff","text":"This example turns RED LED on, waits 2 seconds, then turns RED LED off and GREEN LED on, then after 2 seconds turns GREEN LED off.","title":"Set LED2, LED3 on/off"},{"location":"examples/example-led23/#links","text":"IQRFBB-10 Datasheet IQRF Gateway Daemon Documentation","title":"Links"},{"location":"examples/example-led23/#prerequisities","text":"IQRFBB-10 bonded in working IQRF network. More in Getting Started IQRF Gateway Daemon working. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python WebSockets example","title":"Prerequisities"},{"location":"examples/example-led23/#hardware-wiring","text":"No hardware wiring needed, both LED2 and LED3 are mounted on the board and connected to C1 and C2.","title":"Hardware wiring"},{"location":"examples/example-led23/#software","text":"","title":"Software"},{"location":"examples/example-led23/#a-embedded-json-messages","text":"We use standard DPA handler already loaded in board TR module.","title":"A. Embedded JSON messages"},{"location":"examples/example-led23/#api-json-message","text":"We can manage diods via sending Daemon JSON API messages. LD2 (Green DIOD) ON/OFF Set LEDG request v1-0-0 , ..example Set LEDG response v1-0-0 , ..example LD3 (Red DIOD) ON/OFF Set LEDR request v1-0-0 , ..example Set LEDR response v1-0-0 , ..example","title":"API JSON message"},{"location":"examples/example-led23/#testing-software","text":"The example-led23.py script also prints sent and received JSON messages. Note: Parameter boardAddr must be IQRFBB-10 node address in IQRF network. # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets example-led23.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" LEDR_ON = { \"mType\": \"iqrfEmbedLedr_Set\", \"data\": { \"msgId\": \"testEmbedLedr\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"onOff\": True } }, \"returnVerbose\": True } } LEDR_OFF = { \"mType\": \"iqrfEmbedLedr_Set\", \"data\": { \"msgId\": \"testEmbedLedr\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"onOff\": False } }, \"returnVerbose\": True } } LEDG_ON = { \"mType\": \"iqrfEmbedLedg_Set\", \"data\": { \"msgId\": \"testEmbedLedr\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"onOff\": True } }, \"returnVerbose\": True } } LEDG_OFF = { \"mType\": \"iqrfEmbedLedg_Set\", \"data\": { \"msgId\": \"testEmbedLedr\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"onOff\": False } }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: # RED LED ON await websocket.send(json.dumps(LEDR_ON)) print(f\"Sent > {LEDR_ON}\") response = await websocket.recv() print(f\"Received < {response}\") # Wait 2 sec time.sleep(2) # RED LED OFF await websocket.send(json.dumps(LEDR_OFF)) print(f\"Sent > {LEDR_OFF}\") response = await websocket.recv() print(f\"Received < {response}\") # GREEN LED ON await websocket.send(json.dumps(LEDG_ON)) print(f\"Sent > {LEDG_ON}\") response = await websocket.recv() print(f\"Received < {response}\") # Wait 2 sec time.sleep(2) # GREEN LED OFF await websocket.send(json.dumps(LEDG_OFF)) print(f\"Sent > {LEDG_OFF}\") response = await websocket.recv() print(f\"Received < {response}\") asyncio.get_event_loop().run_until_complete(hello())","title":"Testing Software"},{"location":"examples/example-standardBinOutput/","text":"Standard Binary Output This example shows how to create \"Standard Binary Output\" e.g. relay which will be immediately recognized and manageable from IOT world thanks to gateways and standardization. Standardization does not limit your hardware creativity, your binary output can be relay, LED, or whatever else. In following example we will implement 5 binary outputs on the one board. They will control LED2, LED3, bi-stable relay (2 binary outputs needed) and one external LED. Links IQRFBB-10 Datasheet IQRF Gateway Daemon Documentation IQRF Standards Prerequisities IQRFBB-10 bonded in working IQRF network. More in Getting Started IQRF Gateway Daemon working. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python WebSockets example Hardware wiring Here is wiring of external LED connected to SCL/EX6 pin. Software in TR module The example-standardBinOutput.c implements five binary outputs. Please load this \"Custom DPA Handler\" to TR module on board. Load Custom DPA Handler manual. API JSON message Since we implemented standard binary output we can use all standardized JSON messages for Binary Output via JSON API of gateways. Testing Python code The example-standardBinOutput.py does following: Gets number of implemented binary outputs in TR module. LED2 = ON LED2 = OF, - LED3 = ON LED3 = OFF bi-stable relay = ON bi-stable relay = OFF External LED = ON External LED = OFF","title":"Standard Binary Output"},{"location":"examples/example-standardBinOutput/#standard-binary-output","text":"This example shows how to create \"Standard Binary Output\" e.g. relay which will be immediately recognized and manageable from IOT world thanks to gateways and standardization. Standardization does not limit your hardware creativity, your binary output can be relay, LED, or whatever else. In following example we will implement 5 binary outputs on the one board. They will control LED2, LED3, bi-stable relay (2 binary outputs needed) and one external LED.","title":"Standard Binary Output"},{"location":"examples/example-standardBinOutput/#links","text":"IQRFBB-10 Datasheet IQRF Gateway Daemon Documentation IQRF Standards","title":"Links"},{"location":"examples/example-standardBinOutput/#prerequisities","text":"IQRFBB-10 bonded in working IQRF network. More in Getting Started IQRF Gateway Daemon working. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python WebSockets example","title":"Prerequisities"},{"location":"examples/example-standardBinOutput/#hardware-wiring","text":"Here is wiring of external LED connected to SCL/EX6 pin.","title":"Hardware wiring"},{"location":"examples/example-standardBinOutput/#software-in-tr-module","text":"The example-standardBinOutput.c implements five binary outputs. Please load this \"Custom DPA Handler\" to TR module on board. Load Custom DPA Handler manual.","title":"Software in TR module"},{"location":"examples/example-standardBinOutput/#api-json-message","text":"Since we implemented standard binary output we can use all standardized JSON messages for Binary Output via JSON API of gateways.","title":"API JSON message"},{"location":"examples/example-standardBinOutput/#testing-python-code","text":"The example-standardBinOutput.py does following: Gets number of implemented binary outputs in TR module. LED2 = ON LED2 = OF, - LED3 = ON LED3 = OFF bi-stable relay = ON bi-stable relay = OFF External LED = ON External LED = OFF","title":"Testing Python code"},{"location":"examples/example-standardLight/","text":"Standard Light This example shows how to create \"Standard light\" which means that entire world will know that your device is just a light and will be able to manage it (turn on/off, dim, get status and more). This is possible thanks to standardized API and IQRF gateways. Standardization does not limit your hardware creativity, your light can be whatever you connect. The software in TR module makes connection with API. In following we will show how to implement two lights on the one board. The lights will be LED2 and LED3. Links IQRFBB-10 Datasheet IQRF Gateway Daemon Documentation IQRF Standards Prerequisities IQRFBB-10 bonded in working IQRF network. More in Getting Started IQRF Gateway Daemon working. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python WebSockets example Hardware wiring No hardware wiring needed, lights will be demonstrated by LED2 and LED3. Software in TR module The example-standardLight.c implements two lights on LED2 and LED3 outputs. Please load this \"Custom DPA Handler\" to TR module on board. Load Custom DPA Handler manual. API JSON message Since we implemented standard light we can use standardized JSON messages for management of Lights via JSON API of gateways. Testing Python code The example-standardLight.py turns RED LED on, waits 2 seconds, then turns RED LED off and GREEN LED on, then after 2 seconds turns GREEN LED off. # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets led-on-off.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" LIGHT_ENUM = { \"mType\": \"iqrfLight_Enumerate\", \"data\": { \"msgId\": \"testEmbedLight\", \"req\": { \"nAdr\": boardAddr, \"param\": {} }, \"returnVerbose\": True } } LIGHT1_ON = { \"mType\": \"iqrfLight_SetPower\", \"data\": { \"msgId\": \"testEmbedLight\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"lights\": [ { \"index\": 0, \"power\": 100 } ] } }, \"returnVerbose\": True } } LIGHT1_OFF = { \"mType\": \"iqrfLight_SetPower\", \"data\": { \"msgId\": \"testEmbedLight\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"lights\": [ { \"index\": 0, \"power\": 0 } ] } }, \"returnVerbose\": True } } LIGHT2_ON = { \"mType\": \"iqrfLight_SetPower\", \"data\": { \"msgId\": \"testEmbedLight\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"lights\": [ { \"index\": 1, \"power\": 100 } ] } }, \"returnVerbose\": True } } LIGHT2_OFF = { \"mType\": \"iqrfLight_SetPower\", \"data\": { \"msgId\": \"testEmbedLight\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"lights\": [ { \"index\": 1, \"power\": 0 } ] } }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: # List Lights... await websocket.send(json.dumps(LIGHT_ENUM)) print(f\"Sent > {LIGHT_ENUM}\") response = await websocket.recv() print(f\"Received < {response}\") data = json.loads(response) numLight = data[\"data\"][\"rsp\"][\"result\"][\"lights\"] print(\"-------------------------------------\") print(f\"Node has implemented {numLight} ligts!\") print(\"-------------------------------------\") print(\"wait...\") # Wait 3 sec time.sleep(3) # RED LED ON await websocket.send(json.dumps(LIGHT1_ON)) print(f\"Sent > {LIGHT1_ON}\") response = await websocket.recv() print(f\"Received < {response}\") # Wait 2 sec time.sleep(2) # RED LED OFF await websocket.send(json.dumps(LIGHT1_OFF)) print(f\"Sent > {LIGHT1_OFF}\") response = await websocket.recv() print(f\"Received < {response}\") # GREEN LED ON await websocket.send(json.dumps(LIGHT2_ON)) print(f\"Sent > {LIGHT2_ON}\") response = await websocket.recv() print(f\"Received < {response}\") # Wait 2 sec time.sleep(2) # GREEN LED OFF await websocket.send(json.dumps(LIGHT2_OFF)) print(f\"Sent > {LIGHT2_OFF}\") response = await websocket.recv() print(f\"Received < {response}\") asyncio.get_event_loop().run_until_complete(hello())","title":"Standard Light"},{"location":"examples/example-standardLight/#standard-light","text":"This example shows how to create \"Standard light\" which means that entire world will know that your device is just a light and will be able to manage it (turn on/off, dim, get status and more). This is possible thanks to standardized API and IQRF gateways. Standardization does not limit your hardware creativity, your light can be whatever you connect. The software in TR module makes connection with API. In following we will show how to implement two lights on the one board. The lights will be LED2 and LED3.","title":"Standard Light"},{"location":"examples/example-standardLight/#links","text":"IQRFBB-10 Datasheet IQRF Gateway Daemon Documentation IQRF Standards","title":"Links"},{"location":"examples/example-standardLight/#prerequisities","text":"IQRFBB-10 bonded in working IQRF network. More in Getting Started IQRF Gateway Daemon working. More in IQRF Gateway Daemon Python 3.6 with WebSockets module . More in Python WebSockets example","title":"Prerequisities"},{"location":"examples/example-standardLight/#hardware-wiring","text":"No hardware wiring needed, lights will be demonstrated by LED2 and LED3.","title":"Hardware wiring"},{"location":"examples/example-standardLight/#software-in-tr-module","text":"The example-standardLight.c implements two lights on LED2 and LED3 outputs. Please load this \"Custom DPA Handler\" to TR module on board. Load Custom DPA Handler manual.","title":"Software in TR module"},{"location":"examples/example-standardLight/#api-json-message","text":"Since we implemented standard light we can use standardized JSON messages for management of Lights via JSON API of gateways.","title":"API JSON message"},{"location":"examples/example-standardLight/#testing-python-code","text":"The example-standardLight.py turns RED LED on, waits 2 seconds, then turns RED LED off and GREEN LED on, then after 2 seconds turns GREEN LED off. # # Copyright 2018 Logimic,s.r.o. # www.logimic.com # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # Websockets led-on-off.py import asyncio import websockets import json import time # This is IQRFBB-10 node address in IQRF network boardAddr = 3 # JSON messages by \"https://docs.iqrfsdk.org/iqrf-gateway-daemon/api.html\" LIGHT_ENUM = { \"mType\": \"iqrfLight_Enumerate\", \"data\": { \"msgId\": \"testEmbedLight\", \"req\": { \"nAdr\": boardAddr, \"param\": {} }, \"returnVerbose\": True } } LIGHT1_ON = { \"mType\": \"iqrfLight_SetPower\", \"data\": { \"msgId\": \"testEmbedLight\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"lights\": [ { \"index\": 0, \"power\": 100 } ] } }, \"returnVerbose\": True } } LIGHT1_OFF = { \"mType\": \"iqrfLight_SetPower\", \"data\": { \"msgId\": \"testEmbedLight\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"lights\": [ { \"index\": 0, \"power\": 0 } ] } }, \"returnVerbose\": True } } LIGHT2_ON = { \"mType\": \"iqrfLight_SetPower\", \"data\": { \"msgId\": \"testEmbedLight\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"lights\": [ { \"index\": 1, \"power\": 100 } ] } }, \"returnVerbose\": True } } LIGHT2_OFF = { \"mType\": \"iqrfLight_SetPower\", \"data\": { \"msgId\": \"testEmbedLight\", \"req\": { \"nAdr\": boardAddr, \"param\": { \"lights\": [ { \"index\": 1, \"power\": 0 } ] } }, \"returnVerbose\": True } } async def hello(): # Connect websockets async with websockets.connect( 'ws://localhost:1338') as websocket: # List Lights... await websocket.send(json.dumps(LIGHT_ENUM)) print(f\"Sent > {LIGHT_ENUM}\") response = await websocket.recv() print(f\"Received < {response}\") data = json.loads(response) numLight = data[\"data\"][\"rsp\"][\"result\"][\"lights\"] print(\"-------------------------------------\") print(f\"Node has implemented {numLight} ligts!\") print(\"-------------------------------------\") print(\"wait...\") # Wait 3 sec time.sleep(3) # RED LED ON await websocket.send(json.dumps(LIGHT1_ON)) print(f\"Sent > {LIGHT1_ON}\") response = await websocket.recv() print(f\"Received < {response}\") # Wait 2 sec time.sleep(2) # RED LED OFF await websocket.send(json.dumps(LIGHT1_OFF)) print(f\"Sent > {LIGHT1_OFF}\") response = await websocket.recv() print(f\"Received < {response}\") # GREEN LED ON await websocket.send(json.dumps(LIGHT2_ON)) print(f\"Sent > {LIGHT2_ON}\") response = await websocket.recv() print(f\"Received < {response}\") # Wait 2 sec time.sleep(2) # GREEN LED OFF await websocket.send(json.dumps(LIGHT2_OFF)) print(f\"Sent > {LIGHT2_OFF}\") response = await websocket.recv() print(f\"Received < {response}\") asyncio.get_event_loop().run_until_complete(hello())","title":"Testing Python code"}]}