// ****************************************************************************
//   Custom DPA Handler code example - Standard Lights - Template             *
// ****************************************************************************
// Copyright (c) IQRF Tech s.r.o.
//
// File:    $RCSfile: 1002_Light-Template.c,v $
// Version: $Revision: 1.16 $
// Date:    $Date: 2018/10/25 09:51:28 $
//
// Revision history:
//   2018/10/25  Release for DPA 3.03
//   2017/11/16  Release for DPA 3.02
//   2017/08/14  Release for DPA 3.01
//
// *********************************************************************

// Online DPA documentation http://www.iqrf.org/DpaTechGuide/

// This example implements 2 Lights according to the IQRF Lights standard
//  Index 0: Red LED, only on/off, i.e. 2 levels (0 or 100 %)
//  Index 1: Green LED, only on/off, i.e. 2 levels (0 or 100 %)

// Default IQRF include (modify the path according to your setup)
#include "IQRF.h"

// Default DPA header (modify the path according to your setup)
#include "DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "DPAcustomHandler.h"
// IQRF standards header (modify the path according to your setup)
#include "IQRFstandard.h"
#include "IQRF_HWPID.h"

#if DPA_VERSION_MASTER	< 0x0301
#error DPA version 3.01++ is required
#endif

//############################################################################################

// Number of implemented lights
#define	LIGHTS_COUNT 2

// Light power levels array: every light has 2 bytes, 1st byte is actual power, 2nd byte is requested power
uns16	Powers[LIGHTS_COUNT];

// Sets power of the light, returns previous requested power and returns previous actual power at the global PrevActualPower variable
uns8 SetLight( uns8 index, uns8 reqPower );
static uns8 PrevActualPower;
// Sets FSR0 to point to the 2 bytes of the light powers
void FSR0PowerPointer( uns8 index );

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
bit CustomDpaHandler()
//############################################################################################
{
  // This forces CC5X to wisely use MOVLB instructions (doc says:  The 'default' bank is used by the compiler for loops and labels when the algorithm gives up finding the optimal choice)
#pragma updateBank default = UserBank_01

  // Timers for lights. The space must be long enough to fit them all. 2 bytes per one light.
  static uns16	Timers[LIGHTS_COUNT];

  // Handler presence mark
  clrwdt();

  // Detect DPA event to handle
  switch ( GetDpaEvent() )
  {
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the �empty� return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.

      //  If TMR6 interrupt occurred, every 10 ms
      if ( TMR6IF )
      {
        // Unmask interrupt
        TMR6IF = 0;

        // Count 250 ms from 10 ms micro ticks
        static uns8 count250ms;
        if ( ++count250ms == ( 250 / 10 ) )
        {
          // 250 ms
          count250ms = 0;

          // Pointer to the timers array
          FSR1 = (uns16)&Timers[0];
          // Light index
          static uns8 index;
          index = 0;
          do
          {
            // Is timer running (is non-zero)?
            if ( ( FSR1[1] | INDF1 ) != 0 )
            {
              // Get time
              static uns16 time;
              time.low8 = *FSR1++;
              time.high8 = *FSR1;
              // Is timer over?
              if ( --time == 0 )
                // Turn the light OFF
                SetLight( index, 0 );

              // Store new time
              setINDF1( time.high8 );
              FSR1--;
              setINDF1( time.low8 );
            }
            // Next timer
            FSR1 += sizeof( Timers[0] );
            // Next index
          } while ( ++index < LIGHTS_COUNT );
        }
      }
      return Carry;

      // -------------------------------------------------
    case DpaEvent_DpaRequest:
      // Called to interpret DPA request for peripherals
      // -------------------------------------------------
      // Peripheral enumeration
      IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest()
      {
        // We implement 1 standard peripheral
        _DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1;
        FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_STD_LIGHT );
        _DpaMessage.EnumPeripheralsAnswer.HWPID = HWPID_IQRF_TECH__DEMO_LIGHT;
        _DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0x0001;

DpaHandleReturnTRUE:
        return TRUE;
      }
      // -------------------------------------------------
      // Get information about peripheral
      else
      {
        if ( _PNUM == PNUM_STD_LIGHT )
        {
          _DpaMessage.PeripheralInfoAnswer.PerT = PERIPHERAL_TYPE_STD_LIGHT;
          _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_READ_WRITE;
          // Set standard version
          _DpaMessage.PeripheralInfoAnswer.Par1 = 5;
          goto DpaHandleReturnTRUE;
        }

        break;
      }
      // -------------------------------------------------
      {
        // Handle peripheral command

        // Supported peripheral number?
        if ( _PNUM == PNUM_STD_LIGHT )
        {
          // Supported commands?
          switch ( _PCMD )
          {
            // Invalid command
            default:
              // Return error
              DpaApiReturnPeripheralError( ERROR_PCMD );

              // Light enumeration
            case PCMD_STD_ENUMERATE:
              if ( _DpaDataLength != 0 )
                goto _ERROR_DATA_LEN;

              // Return just count of lights
              _DpaDataLength |= 1;	// Optimization = 1 (_DpaDataLength was zero for sure)
              _DpaMessage.Request.PData[0] = LIGHTS_COUNT;
              goto DpaHandleReturnTRUE;

              // Supported commands.
            case PCMD_STD_LIGHT_SET:
            case PCMD_STD_LIGHT_INC:
            case PCMD_STD_LIGHT_DEC:
            {
              // Invalid bitmap (data) length
              if ( _DpaDataLength < 4 )
              {
                // Return error
_ERROR_DATA_LEN:
                DpaApiReturnPeripheralError( ERROR_DATA_LEN );
              }

              // Store bitmap of lights
              uns8	lightsBitmap[4];
              // Copy bitmap
              lightsBitmap[0] = *FSR0++;
              lightsBitmap[1] = *FSR0++;
              lightsBitmap[2] = *FSR0++;
              lightsBitmap[3] = *FSR0++;

              // Remaining data counter + 1
              _DpaDataLength -= 3;
              // Light index
              uns8 index = 0;
              // Loop all optionally selected lights
              do
              {
                // Light is selected?
                if ( lightsBitmap[0].0 )
                {
                  // Is there enough data for the light?
                  if ( --_DpaDataLength == 0 )
                    goto _ERROR_DATA_LEN;

                  // Get required power value
                  uns8 reqPower = *FSR0++;
                  // NULL required timer value
                  uns16 time = 0;
                  // Is there a timer value?
                  if ( reqPower.7 )
                  {
                    // Un-flag timer value
                    reqPower.7 = 0;
                    // Is there enough data for a timer value?
                    if ( --_DpaDataLength == 0 )
                      goto _ERROR_DATA_LEN;

                    // Get required time
                    time.low8 = *FSR0++;
                    // Valid timer value?
                    if ( ( time.low8 & 0x7F ) == 0 )
                    {
_ERROR_DATA:
                      DpaApiReturnPeripheralError( ERROR_DATA );
                    }

                    // Conversion coefficient, ready for minutes to 250 ms
                    uns8 coef = 60 * ( 1000 / 250 );
                    // Get time in units s/min
                    if ( time.7 )
                    {
                      // Seconds
                      time.7 = 0;
                      // Convert from seconds
                      coef = 1000 / 250;
                    }

                    // Convert to 250 ms
                    time *= coef;
                  }

                  // Is the power parameter correct?
                  if ( reqPower > 100 && reqPower < 0x7F )
                    goto _ERROR_DATA;

                  // Process only implemented lights
                  if ( index < LIGHTS_COUNT )
                  {
                    // Increment or decrement?
                    if ( _PCMD != PCMD_STD_LIGHT_SET )
                    {
                      // Note: we do not report power if parameter for increment or decrement is 0x7F
                      // Get current power
                      uns8 curPower = SetLight( index, 0x7F );
                      // Increment?
                      if ( _PCMD == PCMD_STD_LIGHT_INC )
                      {
                        // Do increment and check for maximum
                        reqPower += curPower;
                        if ( reqPower > 100 )
                          reqPower = 100;
                      }
                      else
                      { // case PCMD_STD_LIGHT_DEC
                        // Do decrement and check for minimum
                        reqPower = curPower - reqPower;
                        if ( (int8)reqPower < 0 )
                          reqPower = 0;
                      }
                    }

                    // Disable timer, so there will be no background activity with the light
                    TMR6ON = FALSE;
                    // Is there a requirement for setting the power level? Then store the timer.
                    if ( reqPower != 0x7f )
                    {
                      // Write timer to the timer database
                      uns16 saveFSR0 = FSR0;
                      FSR0 = index * sizeof( uns16 );
                      FSR0 += (uns16)&Timers[0];
                      setINDF0( time.low8 );
                      FSR0++;
                      setINDF0( time.high8 );
                      FSR0 = saveFSR0;
                    }

                    // Set power and get previous actual power level
                    SetLight( index, reqPower );
                    W = PrevActualPower;
                    // Enable timer again
                    TMR6ON = TRUE;
                  }
                  else
                    // Selected light is not implemented, return 0 power
                    W = 0;

                  // Store previous power to the response
                  setINDF1( W );
                  // Move to the next response byte
                  FSR1++;
                }
                // Shift bitmap
                lightsBitmap[3] = rr( lightsBitmap[3] );
                lightsBitmap[2] = rr( lightsBitmap[2] );
                lightsBitmap[1] = rr( lightsBitmap[1] );
                lightsBitmap[0] = rr( lightsBitmap[0] );
                // Next light index
              } while ( ++index < 32 );

              // Too much data?
              if ( --_DpaDataLength != 0 )
                goto _ERROR_DATA_LEN;

              // Return data
              _DpaDataLength = FSR1L - ( (uns16)&_DpaMessage.Response.PData[0] & 0xFF );
              goto DpaHandleReturnTRUE;
            }
          }
        }

        break;
      }

      // -------------------------------------------------
    case DpaEvent_Init:
      // Do a one time initialization work before main loop starts

  // Setup TMR6 to generate 10 ms ticks
#if F_OSC == 16000000
      PR6 = 250 - 1;
      T6CON = 0b0.1001.1.10;	// Prescaler 16, Postscaler 10, 16 * 10 * 250 = 40000 = 4MHz * 10ms
#else
#error Unsupported oscillator frequency
#endif

      break;

      // -------------------------------------------------
    case DpaEvent_AfterSleep:
      // Called after woken up after sleep

      TMR6IE = TRUE;
      TMR6ON = TRUE;
      break;

      // -------------------------------------------------
    case DpaEvent_BeforeSleep:
      // Called before going to sleep

      // -------------------------------------------------
    case DpaEvent_DisableInterrupts:
      // Called when device needs all hardware interrupts to be disabled (before Reset, Restart and RFPGM)

      // Must not use TMR6 any more
      TMR6ON = FALSE;
      TMR6IE = FALSE;
      break;

    case DpaEvent_FrcValue:
      // Called to get FRC value

      // Check for correct FRC user data
      if ( DataOutBeforeResponseFRC[0] == PNUM_STD_LIGHT )
      {
        // Check for the correct light index and prepare pointer to the power array
        uns8 index = DataOutBeforeResponseFRC[1] & 0x1F;
        if ( index < LIGHTS_COUNT )
        {
          FSR0PowerPointer( index );
          // Check for FRC command
          switch ( _PCMD )
          {
            case FRC_STD_LIGHT_ONOFF:
              responseFRCvalue.1 = 1;
              // Is the light off?
              if ( FSR0[0] == 0 )
                responseFRCvalue.0 = 0;
              break;

            case FRC_STD_LIGHT_ALARM:
              // !EXAMPLE! in this example return alarm if the light power is 100 %
              responseFRCvalue.1 = 1;
              if ( FSR0[0] != 100 )
                responseFRCvalue.0 = 0;
              break;
          }
        }
      }
      goto DpaHandleReturnFALSE;

      // -------------------------------------------------
    case DpaEvent_FrcResponseTime:
      // Called to get FRC response time

      // In this example the FRC commands are fast 
      switch ( DataOutBeforeResponseFRC[0] )
      {
        case FRC_STD_LIGHT_ONOFF:
        case FRC_STD_LIGHT_ALARM:
          responseFRCvalue = _FRC_RESPONSE_TIME_40_MS;
          break;
      }
      break;

  }
DpaHandleReturnFALSE:
  return FALSE;
}

//############################################################################################
// Hand written multiplication using static variables because CC5X uses hidden "automatic" variables so it cannot be called from the interrupt
static uns16 multiplier16;
static uns8 multiplicand8;
static uns16 mul16x8result;
void mul16x8()
//############################################################################################
{
  mul16x8result = 0;
  static uns8 loop;
  loop = 8;
  do
  {
    if ( multiplicand8.0 )
      mul16x8result += multiplier16;
    multiplier16 <<= 1;
    multiplicand8 >>= 1;
  } while ( --loop != 0 );
}


//############################################################################################
void FSR0PowerPointer( uns8 index @ W )
//############################################################################################
{
  // Prepare powers pointer
  FSR0 = index * sizeof( uns16 );
  FSR0 += (uns16)&Powers[0];
}

//############################################################################################
// Note: This method is called in the interrupt too, so all variables and parameters must be static, also in called functions
// IMPORTANT: !beware of the hidden variables generated by compiler e.g. in case of multiplication generated by CC5X
uns8 static _index, _reqPower;
uns8 SetLight( uns8 index @ _index, uns8 reqPower @ _reqPower )
//############################################################################################
{
  // Note: FSRs must not be modified

  // Save FRS0
  static uns16 saveFSR0;
  saveFSR0 = FSR0;
  // Prepare powers pointer
  FSR0PowerPointer( index );
  // Get previous actual power
  PrevActualPower = FSR0[0];
  static uns8 prevReqPower;
  // Get previous required power
  prevReqPower = FSR0[1];
  // If just asking for the power levels, return values, but do not set new power
  if ( reqPower == 0x7F )
    goto _returnNoSet;

  skip( index );
#pragma computedGoto 1
  goto set0;
  goto set1;
#pragma computedGoto 0
  ;
  // --------------------------------------
set1: // Control LEDG by GPIO
  if ( reqPower != 0 )
  {
    // On @ 100%
    _LEDG = 1;
    W = 100;
    goto _return;
  }
  else
  {
    // Off @ 0 %
    _LEDG = 0;
    W = 0;
    goto _return;
  }

  // --------------------------------------
set0: // Control LEDR using 5-bit PIC DAC
  if ( reqPower != 0 )
  {
    // On @ 100%
    _LEDR = 1;
    W = 100;
    goto _return;
  }
  else
  {
    // Off @ 0 %
    _LEDR = 0;
    W = 0;
    goto _return;
  }
 
_return:
  // Store actual power
  setINDF0( W );
  // Store requested power
  FSR0 += 1;
  setINDF0( reqPower );

_returnNoSet:
  FSR0 = saveFSR0;
  // Return required power
  return prevReqPower;
}

//############################################################################################
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup) 
#include "DPAcustomHandler.h"
//############################################################################################
